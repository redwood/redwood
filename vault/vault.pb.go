// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: vault.proto

package vault

import (
	bytes "bytes"
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	redwood_dev_crypto "redwood.dev/crypto"
	redwood_dev_types "redwood.dev/types"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Capability int32

const (
	Capability_Forbidden Capability = 0
	Capability_Fetch     Capability = 1
	Capability_Store     Capability = 2
	Capability_Delete    Capability = 3
	Capability_Admin     Capability = 4
)

var Capability_name = map[int32]string{
	0: "Forbidden",
	1: "Fetch",
	2: "Store",
	3: "Delete",
	4: "Admin",
}

var Capability_value = map[string]int32{
	"Forbidden": 0,
	"Fetch":     1,
	"Store":     2,
	"Delete":    3,
	"Admin":     4,
}

func (Capability) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0adf1cc59b0dff3b, []int{0}
}

type AuthorizeMsg struct {
	// Types that are valid to be assigned to Msg:
	//	*AuthorizeMsg_Challenge_
	//	*AuthorizeMsg_SignedChallenge_
	//	*AuthorizeMsg_Response_
	Msg isAuthorizeMsg_Msg `protobuf_oneof:"msg"`
}

func (m *AuthorizeMsg) Reset()      { *m = AuthorizeMsg{} }
func (*AuthorizeMsg) ProtoMessage() {}
func (*AuthorizeMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_0adf1cc59b0dff3b, []int{0}
}
func (m *AuthorizeMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthorizeMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthorizeMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuthorizeMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthorizeMsg.Merge(m, src)
}
func (m *AuthorizeMsg) XXX_Size() int {
	return m.Size()
}
func (m *AuthorizeMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthorizeMsg.DiscardUnknown(m)
}

var xxx_messageInfo_AuthorizeMsg proto.InternalMessageInfo

type isAuthorizeMsg_Msg interface {
	isAuthorizeMsg_Msg()
	Equal(interface{}) bool
	VerboseEqual(interface{}) error
	MarshalTo([]byte) (int, error)
	Size() int
}

type AuthorizeMsg_Challenge_ struct {
	Challenge *AuthorizeMsg_Challenge `protobuf:"bytes,1,opt,name=challenge,proto3,oneof" json:"challenge,omitempty"`
}
type AuthorizeMsg_SignedChallenge_ struct {
	SignedChallenge *AuthorizeMsg_SignedChallenge `protobuf:"bytes,2,opt,name=signedChallenge,proto3,oneof" json:"signedChallenge,omitempty"`
}
type AuthorizeMsg_Response_ struct {
	Response *AuthorizeMsg_Response `protobuf:"bytes,3,opt,name=response,proto3,oneof" json:"response,omitempty"`
}

func (*AuthorizeMsg_Challenge_) isAuthorizeMsg_Msg()       {}
func (*AuthorizeMsg_SignedChallenge_) isAuthorizeMsg_Msg() {}
func (*AuthorizeMsg_Response_) isAuthorizeMsg_Msg()        {}

func (m *AuthorizeMsg) GetMsg() isAuthorizeMsg_Msg {
	if m != nil {
		return m.Msg
	}
	return nil
}

func (m *AuthorizeMsg) GetChallenge() *AuthorizeMsg_Challenge {
	if x, ok := m.GetMsg().(*AuthorizeMsg_Challenge_); ok {
		return x.Challenge
	}
	return nil
}

func (m *AuthorizeMsg) GetSignedChallenge() *AuthorizeMsg_SignedChallenge {
	if x, ok := m.GetMsg().(*AuthorizeMsg_SignedChallenge_); ok {
		return x.SignedChallenge
	}
	return nil
}

func (m *AuthorizeMsg) GetResponse() *AuthorizeMsg_Response {
	if x, ok := m.GetMsg().(*AuthorizeMsg_Response_); ok {
		return x.Response
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AuthorizeMsg) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AuthorizeMsg_Challenge_)(nil),
		(*AuthorizeMsg_SignedChallenge_)(nil),
		(*AuthorizeMsg_Response_)(nil),
	}
}

type AuthorizeMsg_Challenge struct {
	Challenge []byte `protobuf:"bytes,1,opt,name=challenge,proto3" json:"challenge,omitempty"`
}

func (m *AuthorizeMsg_Challenge) Reset()      { *m = AuthorizeMsg_Challenge{} }
func (*AuthorizeMsg_Challenge) ProtoMessage() {}
func (*AuthorizeMsg_Challenge) Descriptor() ([]byte, []int) {
	return fileDescriptor_0adf1cc59b0dff3b, []int{0, 0}
}
func (m *AuthorizeMsg_Challenge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthorizeMsg_Challenge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthorizeMsg_Challenge.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuthorizeMsg_Challenge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthorizeMsg_Challenge.Merge(m, src)
}
func (m *AuthorizeMsg_Challenge) XXX_Size() int {
	return m.Size()
}
func (m *AuthorizeMsg_Challenge) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthorizeMsg_Challenge.DiscardUnknown(m)
}

var xxx_messageInfo_AuthorizeMsg_Challenge proto.InternalMessageInfo

func (m *AuthorizeMsg_Challenge) GetChallenge() []byte {
	if m != nil {
		return m.Challenge
	}
	return nil
}

type AuthorizeMsg_SignedChallenge struct {
	Signature redwood_dev_crypto.Signature `protobuf:"bytes,1,opt,name=signature,proto3,customtype=redwood.dev/crypto.Signature" json:"signature"`
}

func (m *AuthorizeMsg_SignedChallenge) Reset()      { *m = AuthorizeMsg_SignedChallenge{} }
func (*AuthorizeMsg_SignedChallenge) ProtoMessage() {}
func (*AuthorizeMsg_SignedChallenge) Descriptor() ([]byte, []int) {
	return fileDescriptor_0adf1cc59b0dff3b, []int{0, 1}
}
func (m *AuthorizeMsg_SignedChallenge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthorizeMsg_SignedChallenge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthorizeMsg_SignedChallenge.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuthorizeMsg_SignedChallenge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthorizeMsg_SignedChallenge.Merge(m, src)
}
func (m *AuthorizeMsg_SignedChallenge) XXX_Size() int {
	return m.Size()
}
func (m *AuthorizeMsg_SignedChallenge) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthorizeMsg_SignedChallenge.DiscardUnknown(m)
}

var xxx_messageInfo_AuthorizeMsg_SignedChallenge proto.InternalMessageInfo

type AuthorizeMsg_Response struct {
	Token string `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
}

func (m *AuthorizeMsg_Response) Reset()      { *m = AuthorizeMsg_Response{} }
func (*AuthorizeMsg_Response) ProtoMessage() {}
func (*AuthorizeMsg_Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_0adf1cc59b0dff3b, []int{0, 2}
}
func (m *AuthorizeMsg_Response) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthorizeMsg_Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthorizeMsg_Response.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuthorizeMsg_Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthorizeMsg_Response.Merge(m, src)
}
func (m *AuthorizeMsg_Response) XXX_Size() int {
	return m.Size()
}
func (m *AuthorizeMsg_Response) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthorizeMsg_Response.DiscardUnknown(m)
}

var xxx_messageInfo_AuthorizeMsg_Response proto.InternalMessageInfo

func (m *AuthorizeMsg_Response) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

type ItemsReq struct {
	JWT          string `protobuf:"bytes,1,opt,name=jwt,proto3" json:"jwt,omitempty"`
	CollectionID string `protobuf:"bytes,2,opt,name=collectionID,proto3" json:"collectionID,omitempty"`
	OldestMtime  uint64 `protobuf:"varint,3,opt,name=oldestMtime,proto3" json:"oldestMtime,omitempty"`
	Start        uint64 `protobuf:"varint,4,opt,name=start,proto3" json:"start,omitempty"`
	End          uint64 `protobuf:"varint,5,opt,name=end,proto3" json:"end,omitempty"`
}

func (m *ItemsReq) Reset()      { *m = ItemsReq{} }
func (*ItemsReq) ProtoMessage() {}
func (*ItemsReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_0adf1cc59b0dff3b, []int{1}
}
func (m *ItemsReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ItemsReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ItemsReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ItemsReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ItemsReq.Merge(m, src)
}
func (m *ItemsReq) XXX_Size() int {
	return m.Size()
}
func (m *ItemsReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ItemsReq.DiscardUnknown(m)
}

var xxx_messageInfo_ItemsReq proto.InternalMessageInfo

func (m *ItemsReq) GetJWT() string {
	if m != nil {
		return m.JWT
	}
	return ""
}

func (m *ItemsReq) GetCollectionID() string {
	if m != nil {
		return m.CollectionID
	}
	return ""
}

func (m *ItemsReq) GetOldestMtime() uint64 {
	if m != nil {
		return m.OldestMtime
	}
	return 0
}

func (m *ItemsReq) GetStart() uint64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *ItemsReq) GetEnd() uint64 {
	if m != nil {
		return m.End
	}
	return 0
}

type ItemsResp struct {
	ItemIDs []string `protobuf:"bytes,1,rep,name=itemIDs,proto3" json:"itemIDs,omitempty"`
}

func (m *ItemsResp) Reset()      { *m = ItemsResp{} }
func (*ItemsResp) ProtoMessage() {}
func (*ItemsResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_0adf1cc59b0dff3b, []int{2}
}
func (m *ItemsResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ItemsResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ItemsResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ItemsResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ItemsResp.Merge(m, src)
}
func (m *ItemsResp) XXX_Size() int {
	return m.Size()
}
func (m *ItemsResp) XXX_DiscardUnknown() {
	xxx_messageInfo_ItemsResp.DiscardUnknown(m)
}

var xxx_messageInfo_ItemsResp proto.InternalMessageInfo

func (m *ItemsResp) GetItemIDs() []string {
	if m != nil {
		return m.ItemIDs
	}
	return nil
}

type FetchReq struct {
	JWT          string `protobuf:"bytes,1,opt,name=jwt,proto3" json:"jwt,omitempty"`
	CollectionID string `protobuf:"bytes,2,opt,name=collectionID,proto3" json:"collectionID,omitempty"`
	ItemID       string `protobuf:"bytes,3,opt,name=itemID,proto3" json:"itemID,omitempty"`
}

func (m *FetchReq) Reset()      { *m = FetchReq{} }
func (*FetchReq) ProtoMessage() {}
func (*FetchReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_0adf1cc59b0dff3b, []int{3}
}
func (m *FetchReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FetchReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FetchReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FetchReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FetchReq.Merge(m, src)
}
func (m *FetchReq) XXX_Size() int {
	return m.Size()
}
func (m *FetchReq) XXX_DiscardUnknown() {
	xxx_messageInfo_FetchReq.DiscardUnknown(m)
}

var xxx_messageInfo_FetchReq proto.InternalMessageInfo

func (m *FetchReq) GetJWT() string {
	if m != nil {
		return m.JWT
	}
	return ""
}

func (m *FetchReq) GetCollectionID() string {
	if m != nil {
		return m.CollectionID
	}
	return ""
}

func (m *FetchReq) GetItemID() string {
	if m != nil {
		return m.ItemID
	}
	return ""
}

type FetchResp struct {
	Data  []byte `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	Mtime uint64 `protobuf:"varint,2,opt,name=mtime,proto3" json:"mtime,omitempty"`
	End   bool   `protobuf:"varint,3,opt,name=end,proto3" json:"end,omitempty"`
}

func (m *FetchResp) Reset()      { *m = FetchResp{} }
func (*FetchResp) ProtoMessage() {}
func (*FetchResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_0adf1cc59b0dff3b, []int{4}
}
func (m *FetchResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FetchResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FetchResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FetchResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FetchResp.Merge(m, src)
}
func (m *FetchResp) XXX_Size() int {
	return m.Size()
}
func (m *FetchResp) XXX_DiscardUnknown() {
	xxx_messageInfo_FetchResp.DiscardUnknown(m)
}

var xxx_messageInfo_FetchResp proto.InternalMessageInfo

func (m *FetchResp) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *FetchResp) GetMtime() uint64 {
	if m != nil {
		return m.Mtime
	}
	return 0
}

func (m *FetchResp) GetEnd() bool {
	if m != nil {
		return m.End
	}
	return false
}

type StoreReq struct {
	// Types that are valid to be assigned to Msg:
	//	*StoreReq_Header_
	//	*StoreReq_Payload_
	Msg isStoreReq_Msg `protobuf_oneof:"msg"`
}

func (m *StoreReq) Reset()      { *m = StoreReq{} }
func (*StoreReq) ProtoMessage() {}
func (*StoreReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_0adf1cc59b0dff3b, []int{5}
}
func (m *StoreReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StoreReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StoreReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StoreReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StoreReq.Merge(m, src)
}
func (m *StoreReq) XXX_Size() int {
	return m.Size()
}
func (m *StoreReq) XXX_DiscardUnknown() {
	xxx_messageInfo_StoreReq.DiscardUnknown(m)
}

var xxx_messageInfo_StoreReq proto.InternalMessageInfo

type isStoreReq_Msg interface {
	isStoreReq_Msg()
	Equal(interface{}) bool
	VerboseEqual(interface{}) error
	MarshalTo([]byte) (int, error)
	Size() int
}

type StoreReq_Header_ struct {
	Header *StoreReq_Header `protobuf:"bytes,1,opt,name=header,proto3,oneof" json:"header,omitempty"`
}
type StoreReq_Payload_ struct {
	Payload *StoreReq_Payload `protobuf:"bytes,2,opt,name=payload,proto3,oneof" json:"payload,omitempty"`
}

func (*StoreReq_Header_) isStoreReq_Msg()  {}
func (*StoreReq_Payload_) isStoreReq_Msg() {}

func (m *StoreReq) GetMsg() isStoreReq_Msg {
	if m != nil {
		return m.Msg
	}
	return nil
}

func (m *StoreReq) GetHeader() *StoreReq_Header {
	if x, ok := m.GetMsg().(*StoreReq_Header_); ok {
		return x.Header
	}
	return nil
}

func (m *StoreReq) GetPayload() *StoreReq_Payload {
	if x, ok := m.GetMsg().(*StoreReq_Payload_); ok {
		return x.Payload
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*StoreReq) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*StoreReq_Header_)(nil),
		(*StoreReq_Payload_)(nil),
	}
}

type StoreReq_Header struct {
	JWT          string `protobuf:"bytes,1,opt,name=jwt,proto3" json:"jwt,omitempty"`
	CollectionID string `protobuf:"bytes,2,opt,name=collectionID,proto3" json:"collectionID,omitempty"`
	ItemID       string `protobuf:"bytes,3,opt,name=itemID,proto3" json:"itemID,omitempty"`
}

func (m *StoreReq_Header) Reset()      { *m = StoreReq_Header{} }
func (*StoreReq_Header) ProtoMessage() {}
func (*StoreReq_Header) Descriptor() ([]byte, []int) {
	return fileDescriptor_0adf1cc59b0dff3b, []int{5, 0}
}
func (m *StoreReq_Header) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StoreReq_Header) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StoreReq_Header.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StoreReq_Header) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StoreReq_Header.Merge(m, src)
}
func (m *StoreReq_Header) XXX_Size() int {
	return m.Size()
}
func (m *StoreReq_Header) XXX_DiscardUnknown() {
	xxx_messageInfo_StoreReq_Header.DiscardUnknown(m)
}

var xxx_messageInfo_StoreReq_Header proto.InternalMessageInfo

func (m *StoreReq_Header) GetJWT() string {
	if m != nil {
		return m.JWT
	}
	return ""
}

func (m *StoreReq_Header) GetCollectionID() string {
	if m != nil {
		return m.CollectionID
	}
	return ""
}

func (m *StoreReq_Header) GetItemID() string {
	if m != nil {
		return m.ItemID
	}
	return ""
}

type StoreReq_Payload struct {
	Data []byte `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	End  bool   `protobuf:"varint,2,opt,name=end,proto3" json:"end,omitempty"`
}

func (m *StoreReq_Payload) Reset()      { *m = StoreReq_Payload{} }
func (*StoreReq_Payload) ProtoMessage() {}
func (*StoreReq_Payload) Descriptor() ([]byte, []int) {
	return fileDescriptor_0adf1cc59b0dff3b, []int{5, 1}
}
func (m *StoreReq_Payload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StoreReq_Payload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StoreReq_Payload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StoreReq_Payload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StoreReq_Payload.Merge(m, src)
}
func (m *StoreReq_Payload) XXX_Size() int {
	return m.Size()
}
func (m *StoreReq_Payload) XXX_DiscardUnknown() {
	xxx_messageInfo_StoreReq_Payload.DiscardUnknown(m)
}

var xxx_messageInfo_StoreReq_Payload proto.InternalMessageInfo

func (m *StoreReq_Payload) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *StoreReq_Payload) GetEnd() bool {
	if m != nil {
		return m.End
	}
	return false
}

type StoreResp struct {
}

func (m *StoreResp) Reset()      { *m = StoreResp{} }
func (*StoreResp) ProtoMessage() {}
func (*StoreResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_0adf1cc59b0dff3b, []int{6}
}
func (m *StoreResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StoreResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StoreResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StoreResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StoreResp.Merge(m, src)
}
func (m *StoreResp) XXX_Size() int {
	return m.Size()
}
func (m *StoreResp) XXX_DiscardUnknown() {
	xxx_messageInfo_StoreResp.DiscardUnknown(m)
}

var xxx_messageInfo_StoreResp proto.InternalMessageInfo

type DeleteReq struct {
	JWT          string `protobuf:"bytes,1,opt,name=jwt,proto3" json:"jwt,omitempty"`
	CollectionID string `protobuf:"bytes,2,opt,name=collectionID,proto3" json:"collectionID,omitempty"`
	ItemID       string `protobuf:"bytes,3,opt,name=itemID,proto3" json:"itemID,omitempty"`
}

func (m *DeleteReq) Reset()      { *m = DeleteReq{} }
func (*DeleteReq) ProtoMessage() {}
func (*DeleteReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_0adf1cc59b0dff3b, []int{7}
}
func (m *DeleteReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteReq.Merge(m, src)
}
func (m *DeleteReq) XXX_Size() int {
	return m.Size()
}
func (m *DeleteReq) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteReq.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteReq proto.InternalMessageInfo

func (m *DeleteReq) GetJWT() string {
	if m != nil {
		return m.JWT
	}
	return ""
}

func (m *DeleteReq) GetCollectionID() string {
	if m != nil {
		return m.CollectionID
	}
	return ""
}

func (m *DeleteReq) GetItemID() string {
	if m != nil {
		return m.ItemID
	}
	return ""
}

type DeleteResp struct {
}

func (m *DeleteResp) Reset()      { *m = DeleteResp{} }
func (*DeleteResp) ProtoMessage() {}
func (*DeleteResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_0adf1cc59b0dff3b, []int{8}
}
func (m *DeleteResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteResp.Merge(m, src)
}
func (m *DeleteResp) XXX_Size() int {
	return m.Size()
}
func (m *DeleteResp) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteResp.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteResp proto.InternalMessageInfo

type SetUserCapabilitiesReq struct {
	JWT          string                    `protobuf:"bytes,1,opt,name=jwt,proto3" json:"jwt,omitempty"`
	Address      redwood_dev_types.Address `protobuf:"bytes,2,opt,name=address,proto3,customtype=redwood.dev/types.Address" json:"address"`
	Capabilities []Capability              `protobuf:"varint,3,rep,packed,name=capabilities,proto3,enum=Redwood.vault.Capability" json:"capabilities,omitempty"`
}

func (m *SetUserCapabilitiesReq) Reset()      { *m = SetUserCapabilitiesReq{} }
func (*SetUserCapabilitiesReq) ProtoMessage() {}
func (*SetUserCapabilitiesReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_0adf1cc59b0dff3b, []int{9}
}
func (m *SetUserCapabilitiesReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetUserCapabilitiesReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetUserCapabilitiesReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetUserCapabilitiesReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetUserCapabilitiesReq.Merge(m, src)
}
func (m *SetUserCapabilitiesReq) XXX_Size() int {
	return m.Size()
}
func (m *SetUserCapabilitiesReq) XXX_DiscardUnknown() {
	xxx_messageInfo_SetUserCapabilitiesReq.DiscardUnknown(m)
}

var xxx_messageInfo_SetUserCapabilitiesReq proto.InternalMessageInfo

func (m *SetUserCapabilitiesReq) GetJWT() string {
	if m != nil {
		return m.JWT
	}
	return ""
}

func (m *SetUserCapabilitiesReq) GetCapabilities() []Capability {
	if m != nil {
		return m.Capabilities
	}
	return nil
}

type SetUserCapabilitiesResp struct {
}

func (m *SetUserCapabilitiesResp) Reset()      { *m = SetUserCapabilitiesResp{} }
func (*SetUserCapabilitiesResp) ProtoMessage() {}
func (*SetUserCapabilitiesResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_0adf1cc59b0dff3b, []int{10}
}
func (m *SetUserCapabilitiesResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetUserCapabilitiesResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetUserCapabilitiesResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetUserCapabilitiesResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetUserCapabilitiesResp.Merge(m, src)
}
func (m *SetUserCapabilitiesResp) XXX_Size() int {
	return m.Size()
}
func (m *SetUserCapabilitiesResp) XXX_DiscardUnknown() {
	xxx_messageInfo_SetUserCapabilitiesResp.DiscardUnknown(m)
}

var xxx_messageInfo_SetUserCapabilitiesResp proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("Redwood.vault.Capability", Capability_name, Capability_value)
	proto.RegisterType((*AuthorizeMsg)(nil), "Redwood.vault.AuthorizeMsg")
	proto.RegisterType((*AuthorizeMsg_Challenge)(nil), "Redwood.vault.AuthorizeMsg.Challenge")
	proto.RegisterType((*AuthorizeMsg_SignedChallenge)(nil), "Redwood.vault.AuthorizeMsg.SignedChallenge")
	proto.RegisterType((*AuthorizeMsg_Response)(nil), "Redwood.vault.AuthorizeMsg.Response")
	proto.RegisterType((*ItemsReq)(nil), "Redwood.vault.ItemsReq")
	proto.RegisterType((*ItemsResp)(nil), "Redwood.vault.ItemsResp")
	proto.RegisterType((*FetchReq)(nil), "Redwood.vault.FetchReq")
	proto.RegisterType((*FetchResp)(nil), "Redwood.vault.FetchResp")
	proto.RegisterType((*StoreReq)(nil), "Redwood.vault.StoreReq")
	proto.RegisterType((*StoreReq_Header)(nil), "Redwood.vault.StoreReq.Header")
	proto.RegisterType((*StoreReq_Payload)(nil), "Redwood.vault.StoreReq.Payload")
	proto.RegisterType((*StoreResp)(nil), "Redwood.vault.StoreResp")
	proto.RegisterType((*DeleteReq)(nil), "Redwood.vault.DeleteReq")
	proto.RegisterType((*DeleteResp)(nil), "Redwood.vault.DeleteResp")
	proto.RegisterType((*SetUserCapabilitiesReq)(nil), "Redwood.vault.SetUserCapabilitiesReq")
	proto.RegisterType((*SetUserCapabilitiesResp)(nil), "Redwood.vault.SetUserCapabilitiesResp")
}

func init() { proto.RegisterFile("vault.proto", fileDescriptor_0adf1cc59b0dff3b) }

var fileDescriptor_0adf1cc59b0dff3b = []byte{
	// 905 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x56, 0x3f, 0x8c, 0x1b, 0xc5,
	0x17, 0xde, 0xf1, 0x9e, 0xff, 0xec, 0x3b, 0xff, 0x7e, 0x31, 0xc3, 0x91, 0x5b, 0x2f, 0xd1, 0xd8,
	0x59, 0x25, 0x60, 0x40, 0xf8, 0xa2, 0xa3, 0x41, 0x84, 0x14, 0xe7, 0x3b, 0x82, 0x0f, 0x14, 0x29,
	0x9a, 0x23, 0x44, 0xa2, 0x89, 0xd6, 0xde, 0xc1, 0x5e, 0x58, 0x7b, 0x96, 0x9d, 0x71, 0xa2, 0xa3,
	0xa2, 0xbe, 0x0a, 0x89, 0x0e, 0xe9, 0x7a, 0x3a, 0x24, 0x2a, 0x24, 0x1a, 0xca, 0x94, 0x57, 0x46,
	0x14, 0xa7, 0x78, 0xaf, 0xa1, 0x4c, 0x49, 0x89, 0x76, 0xf6, 0x8f, 0x7d, 0xb6, 0xef, 0xa0, 0x20,
	0xdd, 0xbe, 0xf7, 0xbe, 0xef, 0xbd, 0xef, 0xbd, 0x99, 0x37, 0x36, 0xac, 0x3f, 0x76, 0x26, 0xbe,
	0x6c, 0x07, 0x21, 0x97, 0x1c, 0xff, 0x8f, 0x32, 0xf7, 0x09, 0xe7, 0x6e, 0x5b, 0x39, 0xad, 0x77,
	0x07, 0x9e, 0x1c, 0x4e, 0x7a, 0xed, 0x3e, 0x1f, 0x6d, 0x0d, 0xf8, 0x80, 0x6f, 0x29, 0x54, 0x6f,
	0xf2, 0xa5, 0xb2, 0x94, 0xa1, 0xbe, 0x12, 0xb6, 0x7d, 0xac, 0x43, 0x75, 0x67, 0x22, 0x87, 0x3c,
	0xf4, 0xbe, 0x65, 0xf7, 0xc4, 0x00, 0x7f, 0x04, 0x46, 0x7f, 0xe8, 0xf8, 0x3e, 0x1b, 0x0f, 0x98,
	0x89, 0x9a, 0xa8, 0xb5, 0xbe, 0x7d, 0xb3, 0x7d, 0xae, 0x44, 0x7b, 0x1e, 0xdf, 0xde, 0xcd, 0xc0,
	0x5d, 0x8d, 0xce, 0x98, 0xf8, 0x21, 0x5c, 0x11, 0xde, 0x60, 0xcc, 0xdc, 0x3c, 0x6e, 0x16, 0x54,
	0xb2, 0x77, 0x2e, 0x4b, 0x76, 0x70, 0x9e, 0xd2, 0xd5, 0xe8, 0x62, 0x16, 0xdc, 0x81, 0x4a, 0xc8,
	0x44, 0xc0, 0xc7, 0x82, 0x99, 0xba, 0xca, 0x78, 0xe3, 0xb2, 0x8c, 0x34, 0xc5, 0x76, 0x35, 0x9a,
	0xf3, 0xac, 0xb7, 0xc0, 0x98, 0x25, 0xbc, 0xb6, 0xd8, 0x70, 0x75, 0xae, 0x0f, 0xeb, 0x01, 0x5c,
	0x39, 0x58, 0x52, 0x60, 0xc4, 0xa2, 0x1c, 0x39, 0x09, 0x53, 0x42, 0xe7, 0xc6, 0xd3, 0xd3, 0x86,
	0xf6, 0xc7, 0x69, 0xe3, 0x5a, 0x98, 0x2a, 0x71, 0xd9, 0xe3, 0xad, 0x7e, 0x78, 0x18, 0x48, 0xae,
	0x7a, 0x52, 0x58, 0x3a, 0xa3, 0x59, 0x4d, 0xa8, 0x64, 0xca, 0xf0, 0x06, 0x14, 0x25, 0xff, 0x9a,
	0x8d, 0x55, 0x2e, 0x83, 0x26, 0x46, 0xa7, 0x08, 0xfa, 0x48, 0x0c, 0xec, 0x1f, 0x10, 0x54, 0xf6,
	0x25, 0x1b, 0x09, 0xca, 0xbe, 0xc1, 0x75, 0xd0, 0xbf, 0x7a, 0x22, 0x13, 0x5c, 0xa7, 0x1c, 0x9d,
	0x36, 0xf4, 0x4f, 0x1e, 0x7e, 0x46, 0x63, 0x1f, 0xb6, 0xa1, 0xda, 0xe7, 0xbe, 0xcf, 0xfa, 0xd2,
	0xe3, 0xe3, 0xfd, 0x3d, 0x35, 0x6c, 0x83, 0x9e, 0xf3, 0xe1, 0x26, 0xac, 0x73, 0xdf, 0x65, 0x42,
	0xde, 0x93, 0xde, 0x28, 0x99, 0xde, 0x1a, 0x9d, 0x77, 0xc5, 0x52, 0x84, 0x74, 0x42, 0x69, 0xae,
	0xa9, 0x58, 0x62, 0xe0, 0x1a, 0xe8, 0x6c, 0xec, 0x9a, 0x45, 0xe5, 0x8b, 0x3f, 0xed, 0x9b, 0x60,
	0xa4, 0xa2, 0x44, 0x80, 0x4d, 0x28, 0x7b, 0x92, 0x8d, 0xf6, 0xf7, 0x84, 0x89, 0x9a, 0x7a, 0xcb,
	0xa0, 0x99, 0x69, 0x3b, 0x50, 0xb9, 0xcb, 0x64, 0x7f, 0xf8, 0x1f, 0x68, 0xbf, 0x0a, 0xa5, 0x24,
	0xab, 0x92, 0x6d, 0xd0, 0xd4, 0xb2, 0x3f, 0x06, 0x23, 0x2d, 0x21, 0x02, 0x8c, 0x61, 0xcd, 0x75,
	0xa4, 0x93, 0x9e, 0xa2, 0xfa, 0x8e, 0x5b, 0x1a, 0xa9, 0x76, 0x0b, 0x49, 0x4b, 0xca, 0xc8, 0x5a,
	0x8a, 0x73, 0x55, 0x92, 0x96, 0x7e, 0x2c, 0x40, 0xe5, 0x40, 0xf2, 0x90, 0xc5, 0x62, 0xdf, 0x87,
	0xd2, 0x90, 0x39, 0x2e, 0x0b, 0xd3, 0x0d, 0x20, 0x0b, 0x57, 0x2c, 0x03, 0xb6, 0xbb, 0x0a, 0xd5,
	0xd5, 0x68, 0x8a, 0xc7, 0xb7, 0xa1, 0x1c, 0x38, 0x87, 0x3e, 0x77, 0xdc, 0xf4, 0xbe, 0x37, 0x2e,
	0xa2, 0xde, 0x4f, 0x60, 0x5d, 0x8d, 0x66, 0x0c, 0xeb, 0x11, 0x94, 0x92, 0x84, 0x2f, 0x69, 0x5a,
	0xd6, 0x16, 0x94, 0xd3, 0xb2, 0x2b, 0x67, 0x95, 0x4e, 0xa5, 0x90, 0x4f, 0x25, 0xbb, 0x85, 0xeb,
	0x60, 0xa4, 0xba, 0x45, 0x60, 0xf7, 0xc0, 0xd8, 0x63, 0x3e, 0x93, 0xec, 0x25, 0x1e, 0x6b, 0x15,
	0x20, 0xab, 0x21, 0x02, 0xfb, 0x67, 0x04, 0x57, 0x0f, 0x98, 0x7c, 0x20, 0x58, 0xb8, 0xeb, 0x04,
	0x4e, 0xcf, 0xf3, 0x3d, 0xe9, 0xb1, 0x7f, 0x5a, 0x89, 0xdb, 0x50, 0x76, 0x5c, 0x37, 0x64, 0x42,
	0xa8, 0xd2, 0xd5, 0xce, 0xf5, 0x74, 0x4b, 0xeb, 0xf3, 0x5b, 0x2a, 0x0f, 0x03, 0x26, 0xda, 0x3b,
	0x09, 0x90, 0x66, 0x0c, 0x7c, 0x07, 0xaa, 0xfd, 0xb9, 0x52, 0xa6, 0xde, 0xd4, 0x5b, 0xff, 0xdf,
	0xae, 0x2f, 0x1c, 0x66, 0xae, 0xe6, 0x90, 0x9e, 0x83, 0xdb, 0x75, 0xd8, 0x5c, 0x29, 0x58, 0x04,
	0x6f, 0xff, 0x86, 0x00, 0x66, 0x3c, 0xfc, 0x26, 0x18, 0x77, 0x79, 0xd8, 0xf3, 0x5c, 0x97, 0x8d,
	0x6b, 0x9a, 0x65, 0x1e, 0x1d, 0x37, 0x37, 0x66, 0xe1, 0x47, 0x79, 0x0c, 0x37, 0xa0, 0xa8, 0x6e,
	0x7a, 0x0d, 0x59, 0x1b, 0x47, 0xc7, 0xcd, 0xda, 0x3c, 0x28, 0xf6, 0xc7, 0x00, 0x75, 0x48, 0xb5,
	0xc2, 0x12, 0x40, 0xf9, 0xf1, 0x75, 0x28, 0x25, 0x43, 0xad, 0xe9, 0xd6, 0x6b, 0x47, 0xc7, 0xcd,
	0x57, 0xe6, 0x10, 0x49, 0x20, 0xce, 0xb1, 0xe3, 0x8e, 0xbc, 0x71, 0x6d, 0x6d, 0x29, 0x87, 0xf2,
	0x6f, 0xff, 0xa2, 0x43, 0xe5, 0xf3, 0xb8, 0x77, 0x7a, 0x7f, 0x17, 0xef, 0x83, 0x91, 0x3f, 0xb6,
	0xf8, 0xf5, 0x4b, 0x9e, 0x61, 0xeb, 0xb2, 0x60, 0x0b, 0xdd, 0x42, 0xf8, 0x03, 0x28, 0xaa, 0x17,
	0x05, 0x6f, 0x2e, 0x20, 0xb3, 0xc7, 0xcf, 0x32, 0x57, 0x07, 0x44, 0x80, 0x3f, 0x4c, 0x27, 0xb3,
	0xc4, 0xcd, 0x1e, 0x9f, 0x25, 0x6e, 0xfe, 0x64, 0xdc, 0x42, 0x31, 0x3b, 0x19, 0xcf, 0xe6, 0x05,
	0x9b, 0xba, 0xc4, 0xce, 0x57, 0xa1, 0x85, 0xf0, 0x9d, 0x6c, 0xa6, 0x78, 0x11, 0x95, 0xef, 0x88,
	0x55, 0xbf, 0x20, 0x22, 0x02, 0xec, 0xc2, 0xab, 0x2b, 0xee, 0x09, 0x5e, 0xfc, 0xc5, 0x5d, 0x7d,
	0xf9, 0xad, 0x37, 0xfe, 0x0d, 0x4c, 0x04, 0x9d, 0x4f, 0x4f, 0xa6, 0x44, 0x7b, 0x36, 0x25, 0xda,
	0xf3, 0x29, 0x41, 0x2f, 0xa6, 0x04, 0xfd, 0x35, 0x25, 0xe8, 0xbb, 0x88, 0xa0, 0x9f, 0x22, 0x82,
	0x7e, 0x8d, 0x88, 0xf6, 0x7b, 0x44, 0xd0, 0xd3, 0x88, 0xa0, 0x93, 0x88, 0xa0, 0xe7, 0x11, 0x41,
	0x7f, 0x46, 0x44, 0x7b, 0x11, 0x11, 0xf4, 0xfd, 0x19, 0xd1, 0x4e, 0xce, 0x88, 0xf6, 0xec, 0x8c,
	0x68, 0x5f, 0x14, 0x55, 0x91, 0x5e, 0x49, 0xfd, 0x71, 0x78, 0xef, 0xef, 0x00, 0x00, 0x00, 0xff,
	0xff, 0x59, 0x40, 0x76, 0xae, 0x85, 0x08, 0x00, 0x00,
}

func (x Capability) String() string {
	s, ok := Capability_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *AuthorizeMsg) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*AuthorizeMsg)
	if !ok {
		that2, ok := that.(AuthorizeMsg)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *AuthorizeMsg")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *AuthorizeMsg but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *AuthorizeMsg but is not nil && this == nil")
	}
	if that1.Msg == nil {
		if this.Msg != nil {
			return fmt.Errorf("this.Msg != nil && that1.Msg == nil")
		}
	} else if this.Msg == nil {
		return fmt.Errorf("this.Msg == nil && that1.Msg != nil")
	} else if err := this.Msg.VerboseEqual(that1.Msg); err != nil {
		return err
	}
	return nil
}
func (this *AuthorizeMsg_Challenge_) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*AuthorizeMsg_Challenge_)
	if !ok {
		that2, ok := that.(AuthorizeMsg_Challenge_)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *AuthorizeMsg_Challenge_")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *AuthorizeMsg_Challenge_ but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *AuthorizeMsg_Challenge_ but is not nil && this == nil")
	}
	if !this.Challenge.Equal(that1.Challenge) {
		return fmt.Errorf("Challenge this(%v) Not Equal that(%v)", this.Challenge, that1.Challenge)
	}
	return nil
}
func (this *AuthorizeMsg_SignedChallenge_) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*AuthorizeMsg_SignedChallenge_)
	if !ok {
		that2, ok := that.(AuthorizeMsg_SignedChallenge_)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *AuthorizeMsg_SignedChallenge_")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *AuthorizeMsg_SignedChallenge_ but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *AuthorizeMsg_SignedChallenge_ but is not nil && this == nil")
	}
	if !this.SignedChallenge.Equal(that1.SignedChallenge) {
		return fmt.Errorf("SignedChallenge this(%v) Not Equal that(%v)", this.SignedChallenge, that1.SignedChallenge)
	}
	return nil
}
func (this *AuthorizeMsg_Response_) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*AuthorizeMsg_Response_)
	if !ok {
		that2, ok := that.(AuthorizeMsg_Response_)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *AuthorizeMsg_Response_")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *AuthorizeMsg_Response_ but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *AuthorizeMsg_Response_ but is not nil && this == nil")
	}
	if !this.Response.Equal(that1.Response) {
		return fmt.Errorf("Response this(%v) Not Equal that(%v)", this.Response, that1.Response)
	}
	return nil
}
func (this *AuthorizeMsg) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AuthorizeMsg)
	if !ok {
		that2, ok := that.(AuthorizeMsg)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Msg == nil {
		if this.Msg != nil {
			return false
		}
	} else if this.Msg == nil {
		return false
	} else if !this.Msg.Equal(that1.Msg) {
		return false
	}
	return true
}
func (this *AuthorizeMsg_Challenge_) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AuthorizeMsg_Challenge_)
	if !ok {
		that2, ok := that.(AuthorizeMsg_Challenge_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Challenge.Equal(that1.Challenge) {
		return false
	}
	return true
}
func (this *AuthorizeMsg_SignedChallenge_) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AuthorizeMsg_SignedChallenge_)
	if !ok {
		that2, ok := that.(AuthorizeMsg_SignedChallenge_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SignedChallenge.Equal(that1.SignedChallenge) {
		return false
	}
	return true
}
func (this *AuthorizeMsg_Response_) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AuthorizeMsg_Response_)
	if !ok {
		that2, ok := that.(AuthorizeMsg_Response_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Response.Equal(that1.Response) {
		return false
	}
	return true
}
func (this *AuthorizeMsg_Challenge) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*AuthorizeMsg_Challenge)
	if !ok {
		that2, ok := that.(AuthorizeMsg_Challenge)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *AuthorizeMsg_Challenge")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *AuthorizeMsg_Challenge but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *AuthorizeMsg_Challenge but is not nil && this == nil")
	}
	if !bytes.Equal(this.Challenge, that1.Challenge) {
		return fmt.Errorf("Challenge this(%v) Not Equal that(%v)", this.Challenge, that1.Challenge)
	}
	return nil
}
func (this *AuthorizeMsg_Challenge) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AuthorizeMsg_Challenge)
	if !ok {
		that2, ok := that.(AuthorizeMsg_Challenge)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Challenge, that1.Challenge) {
		return false
	}
	return true
}
func (this *AuthorizeMsg_SignedChallenge) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*AuthorizeMsg_SignedChallenge)
	if !ok {
		that2, ok := that.(AuthorizeMsg_SignedChallenge)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *AuthorizeMsg_SignedChallenge")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *AuthorizeMsg_SignedChallenge but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *AuthorizeMsg_SignedChallenge but is not nil && this == nil")
	}
	if !this.Signature.Equal(that1.Signature) {
		return fmt.Errorf("Signature this(%v) Not Equal that(%v)", this.Signature, that1.Signature)
	}
	return nil
}
func (this *AuthorizeMsg_SignedChallenge) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AuthorizeMsg_SignedChallenge)
	if !ok {
		that2, ok := that.(AuthorizeMsg_SignedChallenge)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Signature.Equal(that1.Signature) {
		return false
	}
	return true
}
func (this *AuthorizeMsg_Response) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*AuthorizeMsg_Response)
	if !ok {
		that2, ok := that.(AuthorizeMsg_Response)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *AuthorizeMsg_Response")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *AuthorizeMsg_Response but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *AuthorizeMsg_Response but is not nil && this == nil")
	}
	if this.Token != that1.Token {
		return fmt.Errorf("Token this(%v) Not Equal that(%v)", this.Token, that1.Token)
	}
	return nil
}
func (this *AuthorizeMsg_Response) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AuthorizeMsg_Response)
	if !ok {
		that2, ok := that.(AuthorizeMsg_Response)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Token != that1.Token {
		return false
	}
	return true
}
func (this *ItemsReq) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*ItemsReq)
	if !ok {
		that2, ok := that.(ItemsReq)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *ItemsReq")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *ItemsReq but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *ItemsReq but is not nil && this == nil")
	}
	if this.JWT != that1.JWT {
		return fmt.Errorf("JWT this(%v) Not Equal that(%v)", this.JWT, that1.JWT)
	}
	if this.CollectionID != that1.CollectionID {
		return fmt.Errorf("CollectionID this(%v) Not Equal that(%v)", this.CollectionID, that1.CollectionID)
	}
	if this.OldestMtime != that1.OldestMtime {
		return fmt.Errorf("OldestMtime this(%v) Not Equal that(%v)", this.OldestMtime, that1.OldestMtime)
	}
	if this.Start != that1.Start {
		return fmt.Errorf("Start this(%v) Not Equal that(%v)", this.Start, that1.Start)
	}
	if this.End != that1.End {
		return fmt.Errorf("End this(%v) Not Equal that(%v)", this.End, that1.End)
	}
	return nil
}
func (this *ItemsReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ItemsReq)
	if !ok {
		that2, ok := that.(ItemsReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.JWT != that1.JWT {
		return false
	}
	if this.CollectionID != that1.CollectionID {
		return false
	}
	if this.OldestMtime != that1.OldestMtime {
		return false
	}
	if this.Start != that1.Start {
		return false
	}
	if this.End != that1.End {
		return false
	}
	return true
}
func (this *ItemsResp) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*ItemsResp)
	if !ok {
		that2, ok := that.(ItemsResp)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *ItemsResp")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *ItemsResp but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *ItemsResp but is not nil && this == nil")
	}
	if len(this.ItemIDs) != len(that1.ItemIDs) {
		return fmt.Errorf("ItemIDs this(%v) Not Equal that(%v)", len(this.ItemIDs), len(that1.ItemIDs))
	}
	for i := range this.ItemIDs {
		if this.ItemIDs[i] != that1.ItemIDs[i] {
			return fmt.Errorf("ItemIDs this[%v](%v) Not Equal that[%v](%v)", i, this.ItemIDs[i], i, that1.ItemIDs[i])
		}
	}
	return nil
}
func (this *ItemsResp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ItemsResp)
	if !ok {
		that2, ok := that.(ItemsResp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.ItemIDs) != len(that1.ItemIDs) {
		return false
	}
	for i := range this.ItemIDs {
		if this.ItemIDs[i] != that1.ItemIDs[i] {
			return false
		}
	}
	return true
}
func (this *FetchReq) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*FetchReq)
	if !ok {
		that2, ok := that.(FetchReq)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *FetchReq")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *FetchReq but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *FetchReq but is not nil && this == nil")
	}
	if this.JWT != that1.JWT {
		return fmt.Errorf("JWT this(%v) Not Equal that(%v)", this.JWT, that1.JWT)
	}
	if this.CollectionID != that1.CollectionID {
		return fmt.Errorf("CollectionID this(%v) Not Equal that(%v)", this.CollectionID, that1.CollectionID)
	}
	if this.ItemID != that1.ItemID {
		return fmt.Errorf("ItemID this(%v) Not Equal that(%v)", this.ItemID, that1.ItemID)
	}
	return nil
}
func (this *FetchReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FetchReq)
	if !ok {
		that2, ok := that.(FetchReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.JWT != that1.JWT {
		return false
	}
	if this.CollectionID != that1.CollectionID {
		return false
	}
	if this.ItemID != that1.ItemID {
		return false
	}
	return true
}
func (this *FetchResp) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*FetchResp)
	if !ok {
		that2, ok := that.(FetchResp)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *FetchResp")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *FetchResp but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *FetchResp but is not nil && this == nil")
	}
	if !bytes.Equal(this.Data, that1.Data) {
		return fmt.Errorf("Data this(%v) Not Equal that(%v)", this.Data, that1.Data)
	}
	if this.Mtime != that1.Mtime {
		return fmt.Errorf("Mtime this(%v) Not Equal that(%v)", this.Mtime, that1.Mtime)
	}
	if this.End != that1.End {
		return fmt.Errorf("End this(%v) Not Equal that(%v)", this.End, that1.End)
	}
	return nil
}
func (this *FetchResp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FetchResp)
	if !ok {
		that2, ok := that.(FetchResp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Data, that1.Data) {
		return false
	}
	if this.Mtime != that1.Mtime {
		return false
	}
	if this.End != that1.End {
		return false
	}
	return true
}
func (this *StoreReq) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*StoreReq)
	if !ok {
		that2, ok := that.(StoreReq)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *StoreReq")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *StoreReq but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *StoreReq but is not nil && this == nil")
	}
	if that1.Msg == nil {
		if this.Msg != nil {
			return fmt.Errorf("this.Msg != nil && that1.Msg == nil")
		}
	} else if this.Msg == nil {
		return fmt.Errorf("this.Msg == nil && that1.Msg != nil")
	} else if err := this.Msg.VerboseEqual(that1.Msg); err != nil {
		return err
	}
	return nil
}
func (this *StoreReq_Header_) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*StoreReq_Header_)
	if !ok {
		that2, ok := that.(StoreReq_Header_)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *StoreReq_Header_")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *StoreReq_Header_ but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *StoreReq_Header_ but is not nil && this == nil")
	}
	if !this.Header.Equal(that1.Header) {
		return fmt.Errorf("Header this(%v) Not Equal that(%v)", this.Header, that1.Header)
	}
	return nil
}
func (this *StoreReq_Payload_) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*StoreReq_Payload_)
	if !ok {
		that2, ok := that.(StoreReq_Payload_)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *StoreReq_Payload_")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *StoreReq_Payload_ but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *StoreReq_Payload_ but is not nil && this == nil")
	}
	if !this.Payload.Equal(that1.Payload) {
		return fmt.Errorf("Payload this(%v) Not Equal that(%v)", this.Payload, that1.Payload)
	}
	return nil
}
func (this *StoreReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StoreReq)
	if !ok {
		that2, ok := that.(StoreReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Msg == nil {
		if this.Msg != nil {
			return false
		}
	} else if this.Msg == nil {
		return false
	} else if !this.Msg.Equal(that1.Msg) {
		return false
	}
	return true
}
func (this *StoreReq_Header_) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StoreReq_Header_)
	if !ok {
		that2, ok := that.(StoreReq_Header_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Header.Equal(that1.Header) {
		return false
	}
	return true
}
func (this *StoreReq_Payload_) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StoreReq_Payload_)
	if !ok {
		that2, ok := that.(StoreReq_Payload_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Payload.Equal(that1.Payload) {
		return false
	}
	return true
}
func (this *StoreReq_Header) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*StoreReq_Header)
	if !ok {
		that2, ok := that.(StoreReq_Header)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *StoreReq_Header")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *StoreReq_Header but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *StoreReq_Header but is not nil && this == nil")
	}
	if this.JWT != that1.JWT {
		return fmt.Errorf("JWT this(%v) Not Equal that(%v)", this.JWT, that1.JWT)
	}
	if this.CollectionID != that1.CollectionID {
		return fmt.Errorf("CollectionID this(%v) Not Equal that(%v)", this.CollectionID, that1.CollectionID)
	}
	if this.ItemID != that1.ItemID {
		return fmt.Errorf("ItemID this(%v) Not Equal that(%v)", this.ItemID, that1.ItemID)
	}
	return nil
}
func (this *StoreReq_Header) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StoreReq_Header)
	if !ok {
		that2, ok := that.(StoreReq_Header)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.JWT != that1.JWT {
		return false
	}
	if this.CollectionID != that1.CollectionID {
		return false
	}
	if this.ItemID != that1.ItemID {
		return false
	}
	return true
}
func (this *StoreReq_Payload) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*StoreReq_Payload)
	if !ok {
		that2, ok := that.(StoreReq_Payload)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *StoreReq_Payload")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *StoreReq_Payload but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *StoreReq_Payload but is not nil && this == nil")
	}
	if !bytes.Equal(this.Data, that1.Data) {
		return fmt.Errorf("Data this(%v) Not Equal that(%v)", this.Data, that1.Data)
	}
	if this.End != that1.End {
		return fmt.Errorf("End this(%v) Not Equal that(%v)", this.End, that1.End)
	}
	return nil
}
func (this *StoreReq_Payload) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StoreReq_Payload)
	if !ok {
		that2, ok := that.(StoreReq_Payload)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Data, that1.Data) {
		return false
	}
	if this.End != that1.End {
		return false
	}
	return true
}
func (this *StoreResp) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*StoreResp)
	if !ok {
		that2, ok := that.(StoreResp)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *StoreResp")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *StoreResp but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *StoreResp but is not nil && this == nil")
	}
	return nil
}
func (this *StoreResp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StoreResp)
	if !ok {
		that2, ok := that.(StoreResp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *DeleteReq) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*DeleteReq)
	if !ok {
		that2, ok := that.(DeleteReq)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *DeleteReq")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *DeleteReq but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *DeleteReq but is not nil && this == nil")
	}
	if this.JWT != that1.JWT {
		return fmt.Errorf("JWT this(%v) Not Equal that(%v)", this.JWT, that1.JWT)
	}
	if this.CollectionID != that1.CollectionID {
		return fmt.Errorf("CollectionID this(%v) Not Equal that(%v)", this.CollectionID, that1.CollectionID)
	}
	if this.ItemID != that1.ItemID {
		return fmt.Errorf("ItemID this(%v) Not Equal that(%v)", this.ItemID, that1.ItemID)
	}
	return nil
}
func (this *DeleteReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeleteReq)
	if !ok {
		that2, ok := that.(DeleteReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.JWT != that1.JWT {
		return false
	}
	if this.CollectionID != that1.CollectionID {
		return false
	}
	if this.ItemID != that1.ItemID {
		return false
	}
	return true
}
func (this *DeleteResp) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*DeleteResp)
	if !ok {
		that2, ok := that.(DeleteResp)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *DeleteResp")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *DeleteResp but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *DeleteResp but is not nil && this == nil")
	}
	return nil
}
func (this *DeleteResp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeleteResp)
	if !ok {
		that2, ok := that.(DeleteResp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *SetUserCapabilitiesReq) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*SetUserCapabilitiesReq)
	if !ok {
		that2, ok := that.(SetUserCapabilitiesReq)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *SetUserCapabilitiesReq")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *SetUserCapabilitiesReq but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *SetUserCapabilitiesReq but is not nil && this == nil")
	}
	if this.JWT != that1.JWT {
		return fmt.Errorf("JWT this(%v) Not Equal that(%v)", this.JWT, that1.JWT)
	}
	if !this.Address.Equal(that1.Address) {
		return fmt.Errorf("Address this(%v) Not Equal that(%v)", this.Address, that1.Address)
	}
	if len(this.Capabilities) != len(that1.Capabilities) {
		return fmt.Errorf("Capabilities this(%v) Not Equal that(%v)", len(this.Capabilities), len(that1.Capabilities))
	}
	for i := range this.Capabilities {
		if this.Capabilities[i] != that1.Capabilities[i] {
			return fmt.Errorf("Capabilities this[%v](%v) Not Equal that[%v](%v)", i, this.Capabilities[i], i, that1.Capabilities[i])
		}
	}
	return nil
}
func (this *SetUserCapabilitiesReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SetUserCapabilitiesReq)
	if !ok {
		that2, ok := that.(SetUserCapabilitiesReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.JWT != that1.JWT {
		return false
	}
	if !this.Address.Equal(that1.Address) {
		return false
	}
	if len(this.Capabilities) != len(that1.Capabilities) {
		return false
	}
	for i := range this.Capabilities {
		if this.Capabilities[i] != that1.Capabilities[i] {
			return false
		}
	}
	return true
}
func (this *SetUserCapabilitiesResp) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*SetUserCapabilitiesResp)
	if !ok {
		that2, ok := that.(SetUserCapabilitiesResp)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *SetUserCapabilitiesResp")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *SetUserCapabilitiesResp but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *SetUserCapabilitiesResp but is not nil && this == nil")
	}
	return nil
}
func (this *SetUserCapabilitiesResp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SetUserCapabilitiesResp)
	if !ok {
		that2, ok := that.(SetUserCapabilitiesResp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *AuthorizeMsg) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&vault.AuthorizeMsg{")
	if this.Msg != nil {
		s = append(s, "Msg: "+fmt.Sprintf("%#v", this.Msg)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AuthorizeMsg_Challenge_) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&vault.AuthorizeMsg_Challenge_{` +
		`Challenge:` + fmt.Sprintf("%#v", this.Challenge) + `}`}, ", ")
	return s
}
func (this *AuthorizeMsg_SignedChallenge_) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&vault.AuthorizeMsg_SignedChallenge_{` +
		`SignedChallenge:` + fmt.Sprintf("%#v", this.SignedChallenge) + `}`}, ", ")
	return s
}
func (this *AuthorizeMsg_Response_) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&vault.AuthorizeMsg_Response_{` +
		`Response:` + fmt.Sprintf("%#v", this.Response) + `}`}, ", ")
	return s
}
func (this *AuthorizeMsg_Challenge) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&vault.AuthorizeMsg_Challenge{")
	s = append(s, "Challenge: "+fmt.Sprintf("%#v", this.Challenge)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AuthorizeMsg_SignedChallenge) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&vault.AuthorizeMsg_SignedChallenge{")
	s = append(s, "Signature: "+fmt.Sprintf("%#v", this.Signature)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AuthorizeMsg_Response) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&vault.AuthorizeMsg_Response{")
	s = append(s, "Token: "+fmt.Sprintf("%#v", this.Token)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ItemsReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&vault.ItemsReq{")
	s = append(s, "JWT: "+fmt.Sprintf("%#v", this.JWT)+",\n")
	s = append(s, "CollectionID: "+fmt.Sprintf("%#v", this.CollectionID)+",\n")
	s = append(s, "OldestMtime: "+fmt.Sprintf("%#v", this.OldestMtime)+",\n")
	s = append(s, "Start: "+fmt.Sprintf("%#v", this.Start)+",\n")
	s = append(s, "End: "+fmt.Sprintf("%#v", this.End)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ItemsResp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&vault.ItemsResp{")
	s = append(s, "ItemIDs: "+fmt.Sprintf("%#v", this.ItemIDs)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FetchReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&vault.FetchReq{")
	s = append(s, "JWT: "+fmt.Sprintf("%#v", this.JWT)+",\n")
	s = append(s, "CollectionID: "+fmt.Sprintf("%#v", this.CollectionID)+",\n")
	s = append(s, "ItemID: "+fmt.Sprintf("%#v", this.ItemID)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FetchResp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&vault.FetchResp{")
	s = append(s, "Data: "+fmt.Sprintf("%#v", this.Data)+",\n")
	s = append(s, "Mtime: "+fmt.Sprintf("%#v", this.Mtime)+",\n")
	s = append(s, "End: "+fmt.Sprintf("%#v", this.End)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StoreReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&vault.StoreReq{")
	if this.Msg != nil {
		s = append(s, "Msg: "+fmt.Sprintf("%#v", this.Msg)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StoreReq_Header_) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&vault.StoreReq_Header_{` +
		`Header:` + fmt.Sprintf("%#v", this.Header) + `}`}, ", ")
	return s
}
func (this *StoreReq_Payload_) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&vault.StoreReq_Payload_{` +
		`Payload:` + fmt.Sprintf("%#v", this.Payload) + `}`}, ", ")
	return s
}
func (this *StoreReq_Header) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&vault.StoreReq_Header{")
	s = append(s, "JWT: "+fmt.Sprintf("%#v", this.JWT)+",\n")
	s = append(s, "CollectionID: "+fmt.Sprintf("%#v", this.CollectionID)+",\n")
	s = append(s, "ItemID: "+fmt.Sprintf("%#v", this.ItemID)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StoreReq_Payload) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&vault.StoreReq_Payload{")
	s = append(s, "Data: "+fmt.Sprintf("%#v", this.Data)+",\n")
	s = append(s, "End: "+fmt.Sprintf("%#v", this.End)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StoreResp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&vault.StoreResp{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeleteReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&vault.DeleteReq{")
	s = append(s, "JWT: "+fmt.Sprintf("%#v", this.JWT)+",\n")
	s = append(s, "CollectionID: "+fmt.Sprintf("%#v", this.CollectionID)+",\n")
	s = append(s, "ItemID: "+fmt.Sprintf("%#v", this.ItemID)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeleteResp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&vault.DeleteResp{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SetUserCapabilitiesReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&vault.SetUserCapabilitiesReq{")
	s = append(s, "JWT: "+fmt.Sprintf("%#v", this.JWT)+",\n")
	s = append(s, "Address: "+fmt.Sprintf("%#v", this.Address)+",\n")
	s = append(s, "Capabilities: "+fmt.Sprintf("%#v", this.Capabilities)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SetUserCapabilitiesResp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&vault.SetUserCapabilitiesResp{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringVault(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// VaultRPCClient is the client API for VaultRPC service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type VaultRPCClient interface {
	Authorize(ctx context.Context, opts ...grpc.CallOption) (VaultRPC_AuthorizeClient, error)
	Items(ctx context.Context, in *ItemsReq, opts ...grpc.CallOption) (*ItemsResp, error)
	Fetch(ctx context.Context, in *FetchReq, opts ...grpc.CallOption) (VaultRPC_FetchClient, error)
	Store(ctx context.Context, opts ...grpc.CallOption) (VaultRPC_StoreClient, error)
	Delete(ctx context.Context, in *DeleteReq, opts ...grpc.CallOption) (*DeleteResp, error)
	SetUserCapabilities(ctx context.Context, in *SetUserCapabilitiesReq, opts ...grpc.CallOption) (*SetUserCapabilitiesResp, error)
}

type vaultRPCClient struct {
	cc *grpc.ClientConn
}

func NewVaultRPCClient(cc *grpc.ClientConn) VaultRPCClient {
	return &vaultRPCClient{cc}
}

func (c *vaultRPCClient) Authorize(ctx context.Context, opts ...grpc.CallOption) (VaultRPC_AuthorizeClient, error) {
	stream, err := c.cc.NewStream(ctx, &_VaultRPC_serviceDesc.Streams[0], "/Redwood.vault.VaultRPC/Authorize", opts...)
	if err != nil {
		return nil, err
	}
	x := &vaultRPCAuthorizeClient{stream}
	return x, nil
}

type VaultRPC_AuthorizeClient interface {
	Send(*AuthorizeMsg) error
	Recv() (*AuthorizeMsg, error)
	grpc.ClientStream
}

type vaultRPCAuthorizeClient struct {
	grpc.ClientStream
}

func (x *vaultRPCAuthorizeClient) Send(m *AuthorizeMsg) error {
	return x.ClientStream.SendMsg(m)
}

func (x *vaultRPCAuthorizeClient) Recv() (*AuthorizeMsg, error) {
	m := new(AuthorizeMsg)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *vaultRPCClient) Items(ctx context.Context, in *ItemsReq, opts ...grpc.CallOption) (*ItemsResp, error) {
	out := new(ItemsResp)
	err := c.cc.Invoke(ctx, "/Redwood.vault.VaultRPC/Items", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultRPCClient) Fetch(ctx context.Context, in *FetchReq, opts ...grpc.CallOption) (VaultRPC_FetchClient, error) {
	stream, err := c.cc.NewStream(ctx, &_VaultRPC_serviceDesc.Streams[1], "/Redwood.vault.VaultRPC/Fetch", opts...)
	if err != nil {
		return nil, err
	}
	x := &vaultRPCFetchClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type VaultRPC_FetchClient interface {
	Recv() (*FetchResp, error)
	grpc.ClientStream
}

type vaultRPCFetchClient struct {
	grpc.ClientStream
}

func (x *vaultRPCFetchClient) Recv() (*FetchResp, error) {
	m := new(FetchResp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *vaultRPCClient) Store(ctx context.Context, opts ...grpc.CallOption) (VaultRPC_StoreClient, error) {
	stream, err := c.cc.NewStream(ctx, &_VaultRPC_serviceDesc.Streams[2], "/Redwood.vault.VaultRPC/Store", opts...)
	if err != nil {
		return nil, err
	}
	x := &vaultRPCStoreClient{stream}
	return x, nil
}

type VaultRPC_StoreClient interface {
	Send(*StoreReq) error
	CloseAndRecv() (*StoreResp, error)
	grpc.ClientStream
}

type vaultRPCStoreClient struct {
	grpc.ClientStream
}

func (x *vaultRPCStoreClient) Send(m *StoreReq) error {
	return x.ClientStream.SendMsg(m)
}

func (x *vaultRPCStoreClient) CloseAndRecv() (*StoreResp, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(StoreResp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *vaultRPCClient) Delete(ctx context.Context, in *DeleteReq, opts ...grpc.CallOption) (*DeleteResp, error) {
	out := new(DeleteResp)
	err := c.cc.Invoke(ctx, "/Redwood.vault.VaultRPC/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultRPCClient) SetUserCapabilities(ctx context.Context, in *SetUserCapabilitiesReq, opts ...grpc.CallOption) (*SetUserCapabilitiesResp, error) {
	out := new(SetUserCapabilitiesResp)
	err := c.cc.Invoke(ctx, "/Redwood.vault.VaultRPC/SetUserCapabilities", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VaultRPCServer is the server API for VaultRPC service.
type VaultRPCServer interface {
	Authorize(VaultRPC_AuthorizeServer) error
	Items(context.Context, *ItemsReq) (*ItemsResp, error)
	Fetch(*FetchReq, VaultRPC_FetchServer) error
	Store(VaultRPC_StoreServer) error
	Delete(context.Context, *DeleteReq) (*DeleteResp, error)
	SetUserCapabilities(context.Context, *SetUserCapabilitiesReq) (*SetUserCapabilitiesResp, error)
}

// UnimplementedVaultRPCServer can be embedded to have forward compatible implementations.
type UnimplementedVaultRPCServer struct {
}

func (*UnimplementedVaultRPCServer) Authorize(srv VaultRPC_AuthorizeServer) error {
	return status.Errorf(codes.Unimplemented, "method Authorize not implemented")
}
func (*UnimplementedVaultRPCServer) Items(ctx context.Context, req *ItemsReq) (*ItemsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Items not implemented")
}
func (*UnimplementedVaultRPCServer) Fetch(req *FetchReq, srv VaultRPC_FetchServer) error {
	return status.Errorf(codes.Unimplemented, "method Fetch not implemented")
}
func (*UnimplementedVaultRPCServer) Store(srv VaultRPC_StoreServer) error {
	return status.Errorf(codes.Unimplemented, "method Store not implemented")
}
func (*UnimplementedVaultRPCServer) Delete(ctx context.Context, req *DeleteReq) (*DeleteResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (*UnimplementedVaultRPCServer) SetUserCapabilities(ctx context.Context, req *SetUserCapabilitiesReq) (*SetUserCapabilitiesResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetUserCapabilities not implemented")
}

func RegisterVaultRPCServer(s *grpc.Server, srv VaultRPCServer) {
	s.RegisterService(&_VaultRPC_serviceDesc, srv)
}

func _VaultRPC_Authorize_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(VaultRPCServer).Authorize(&vaultRPCAuthorizeServer{stream})
}

type VaultRPC_AuthorizeServer interface {
	Send(*AuthorizeMsg) error
	Recv() (*AuthorizeMsg, error)
	grpc.ServerStream
}

type vaultRPCAuthorizeServer struct {
	grpc.ServerStream
}

func (x *vaultRPCAuthorizeServer) Send(m *AuthorizeMsg) error {
	return x.ServerStream.SendMsg(m)
}

func (x *vaultRPCAuthorizeServer) Recv() (*AuthorizeMsg, error) {
	m := new(AuthorizeMsg)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _VaultRPC_Items_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ItemsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VaultRPCServer).Items(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Redwood.vault.VaultRPC/Items",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VaultRPCServer).Items(ctx, req.(*ItemsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _VaultRPC_Fetch_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(FetchReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(VaultRPCServer).Fetch(m, &vaultRPCFetchServer{stream})
}

type VaultRPC_FetchServer interface {
	Send(*FetchResp) error
	grpc.ServerStream
}

type vaultRPCFetchServer struct {
	grpc.ServerStream
}

func (x *vaultRPCFetchServer) Send(m *FetchResp) error {
	return x.ServerStream.SendMsg(m)
}

func _VaultRPC_Store_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(VaultRPCServer).Store(&vaultRPCStoreServer{stream})
}

type VaultRPC_StoreServer interface {
	SendAndClose(*StoreResp) error
	Recv() (*StoreReq, error)
	grpc.ServerStream
}

type vaultRPCStoreServer struct {
	grpc.ServerStream
}

func (x *vaultRPCStoreServer) SendAndClose(m *StoreResp) error {
	return x.ServerStream.SendMsg(m)
}

func (x *vaultRPCStoreServer) Recv() (*StoreReq, error) {
	m := new(StoreReq)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _VaultRPC_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VaultRPCServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Redwood.vault.VaultRPC/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VaultRPCServer).Delete(ctx, req.(*DeleteReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _VaultRPC_SetUserCapabilities_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetUserCapabilitiesReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VaultRPCServer).SetUserCapabilities(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Redwood.vault.VaultRPC/SetUserCapabilities",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VaultRPCServer).SetUserCapabilities(ctx, req.(*SetUserCapabilitiesReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _VaultRPC_serviceDesc = grpc.ServiceDesc{
	ServiceName: "Redwood.vault.VaultRPC",
	HandlerType: (*VaultRPCServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Items",
			Handler:    _VaultRPC_Items_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _VaultRPC_Delete_Handler,
		},
		{
			MethodName: "SetUserCapabilities",
			Handler:    _VaultRPC_SetUserCapabilities_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Authorize",
			Handler:       _VaultRPC_Authorize_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "Fetch",
			Handler:       _VaultRPC_Fetch_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Store",
			Handler:       _VaultRPC_Store_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "vault.proto",
}

func (m *AuthorizeMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthorizeMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthorizeMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Msg != nil {
		{
			size := m.Msg.Size()
			i -= size
			if _, err := m.Msg.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *AuthorizeMsg_Challenge_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthorizeMsg_Challenge_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Challenge != nil {
		{
			size, err := m.Challenge.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVault(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *AuthorizeMsg_SignedChallenge_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthorizeMsg_SignedChallenge_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SignedChallenge != nil {
		{
			size, err := m.SignedChallenge.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVault(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *AuthorizeMsg_Response_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthorizeMsg_Response_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Response != nil {
		{
			size, err := m.Response.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVault(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *AuthorizeMsg_Challenge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthorizeMsg_Challenge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthorizeMsg_Challenge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Challenge) > 0 {
		i -= len(m.Challenge)
		copy(dAtA[i:], m.Challenge)
		i = encodeVarintVault(dAtA, i, uint64(len(m.Challenge)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AuthorizeMsg_SignedChallenge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthorizeMsg_SignedChallenge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthorizeMsg_SignedChallenge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Signature.Size()
		i -= size
		if _, err := m.Signature.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintVault(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AuthorizeMsg_Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthorizeMsg_Response) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthorizeMsg_Response) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintVault(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ItemsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ItemsReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ItemsReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.End != 0 {
		i = encodeVarintVault(dAtA, i, uint64(m.End))
		i--
		dAtA[i] = 0x28
	}
	if m.Start != 0 {
		i = encodeVarintVault(dAtA, i, uint64(m.Start))
		i--
		dAtA[i] = 0x20
	}
	if m.OldestMtime != 0 {
		i = encodeVarintVault(dAtA, i, uint64(m.OldestMtime))
		i--
		dAtA[i] = 0x18
	}
	if len(m.CollectionID) > 0 {
		i -= len(m.CollectionID)
		copy(dAtA[i:], m.CollectionID)
		i = encodeVarintVault(dAtA, i, uint64(len(m.CollectionID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.JWT) > 0 {
		i -= len(m.JWT)
		copy(dAtA[i:], m.JWT)
		i = encodeVarintVault(dAtA, i, uint64(len(m.JWT)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ItemsResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ItemsResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ItemsResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ItemIDs) > 0 {
		for iNdEx := len(m.ItemIDs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ItemIDs[iNdEx])
			copy(dAtA[i:], m.ItemIDs[iNdEx])
			i = encodeVarintVault(dAtA, i, uint64(len(m.ItemIDs[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *FetchReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FetchReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ItemID) > 0 {
		i -= len(m.ItemID)
		copy(dAtA[i:], m.ItemID)
		i = encodeVarintVault(dAtA, i, uint64(len(m.ItemID)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.CollectionID) > 0 {
		i -= len(m.CollectionID)
		copy(dAtA[i:], m.CollectionID)
		i = encodeVarintVault(dAtA, i, uint64(len(m.CollectionID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.JWT) > 0 {
		i -= len(m.JWT)
		copy(dAtA[i:], m.JWT)
		i = encodeVarintVault(dAtA, i, uint64(len(m.JWT)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FetchResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FetchResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.End {
		i--
		if m.End {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Mtime != 0 {
		i = encodeVarintVault(dAtA, i, uint64(m.Mtime))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintVault(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StoreReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StoreReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StoreReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Msg != nil {
		{
			size := m.Msg.Size()
			i -= size
			if _, err := m.Msg.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *StoreReq_Header_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StoreReq_Header_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVault(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *StoreReq_Payload_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StoreReq_Payload_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Payload != nil {
		{
			size, err := m.Payload.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVault(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *StoreReq_Header) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StoreReq_Header) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StoreReq_Header) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ItemID) > 0 {
		i -= len(m.ItemID)
		copy(dAtA[i:], m.ItemID)
		i = encodeVarintVault(dAtA, i, uint64(len(m.ItemID)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.CollectionID) > 0 {
		i -= len(m.CollectionID)
		copy(dAtA[i:], m.CollectionID)
		i = encodeVarintVault(dAtA, i, uint64(len(m.CollectionID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.JWT) > 0 {
		i -= len(m.JWT)
		copy(dAtA[i:], m.JWT)
		i = encodeVarintVault(dAtA, i, uint64(len(m.JWT)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StoreReq_Payload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StoreReq_Payload) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StoreReq_Payload) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.End {
		i--
		if m.End {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintVault(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StoreResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StoreResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StoreResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *DeleteReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ItemID) > 0 {
		i -= len(m.ItemID)
		copy(dAtA[i:], m.ItemID)
		i = encodeVarintVault(dAtA, i, uint64(len(m.ItemID)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.CollectionID) > 0 {
		i -= len(m.CollectionID)
		copy(dAtA[i:], m.CollectionID)
		i = encodeVarintVault(dAtA, i, uint64(len(m.CollectionID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.JWT) > 0 {
		i -= len(m.JWT)
		copy(dAtA[i:], m.JWT)
		i = encodeVarintVault(dAtA, i, uint64(len(m.JWT)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeleteResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *SetUserCapabilitiesReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetUserCapabilitiesReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetUserCapabilitiesReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Capabilities) > 0 {
		dAtA7 := make([]byte, len(m.Capabilities)*10)
		var j6 int
		for _, num := range m.Capabilities {
			for num >= 1<<7 {
				dAtA7[j6] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j6++
			}
			dAtA7[j6] = uint8(num)
			j6++
		}
		i -= j6
		copy(dAtA[i:], dAtA7[:j6])
		i = encodeVarintVault(dAtA, i, uint64(j6))
		i--
		dAtA[i] = 0x1a
	}
	{
		size := m.Address.Size()
		i -= size
		if _, err := m.Address.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintVault(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.JWT) > 0 {
		i -= len(m.JWT)
		copy(dAtA[i:], m.JWT)
		i = encodeVarintVault(dAtA, i, uint64(len(m.JWT)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SetUserCapabilitiesResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetUserCapabilitiesResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetUserCapabilitiesResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func encodeVarintVault(dAtA []byte, offset int, v uint64) int {
	offset -= sovVault(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func NewPopulatedAuthorizeMsg(r randyVault, easy bool) *AuthorizeMsg {
	this := &AuthorizeMsg{}
	oneofNumber_Msg := []int32{1, 2, 3}[r.Intn(3)]
	switch oneofNumber_Msg {
	case 1:
		this.Msg = NewPopulatedAuthorizeMsg_Challenge_(r, easy)
	case 2:
		this.Msg = NewPopulatedAuthorizeMsg_SignedChallenge_(r, easy)
	case 3:
		this.Msg = NewPopulatedAuthorizeMsg_Response_(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedAuthorizeMsg_Challenge_(r randyVault, easy bool) *AuthorizeMsg_Challenge_ {
	this := &AuthorizeMsg_Challenge_{}
	this.Challenge = NewPopulatedAuthorizeMsg_Challenge(r, easy)
	return this
}
func NewPopulatedAuthorizeMsg_SignedChallenge_(r randyVault, easy bool) *AuthorizeMsg_SignedChallenge_ {
	this := &AuthorizeMsg_SignedChallenge_{}
	this.SignedChallenge = NewPopulatedAuthorizeMsg_SignedChallenge(r, easy)
	return this
}
func NewPopulatedAuthorizeMsg_Response_(r randyVault, easy bool) *AuthorizeMsg_Response_ {
	this := &AuthorizeMsg_Response_{}
	this.Response = NewPopulatedAuthorizeMsg_Response(r, easy)
	return this
}
func NewPopulatedAuthorizeMsg_Challenge(r randyVault, easy bool) *AuthorizeMsg_Challenge {
	this := &AuthorizeMsg_Challenge{}
	v1 := r.Intn(100)
	this.Challenge = make([]byte, v1)
	for i := 0; i < v1; i++ {
		this.Challenge[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedAuthorizeMsg_SignedChallenge(r randyVault, easy bool) *AuthorizeMsg_SignedChallenge {
	this := &AuthorizeMsg_SignedChallenge{}
	v2 := redwood_dev_crypto.NewPopulatedSignature(r)
	this.Signature = *v2
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedAuthorizeMsg_Response(r randyVault, easy bool) *AuthorizeMsg_Response {
	this := &AuthorizeMsg_Response{}
	this.Token = string(randStringVault(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedItemsReq(r randyVault, easy bool) *ItemsReq {
	this := &ItemsReq{}
	this.JWT = string(randStringVault(r))
	this.CollectionID = string(randStringVault(r))
	this.OldestMtime = uint64(uint64(r.Uint32()))
	this.Start = uint64(uint64(r.Uint32()))
	this.End = uint64(uint64(r.Uint32()))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedItemsResp(r randyVault, easy bool) *ItemsResp {
	this := &ItemsResp{}
	v3 := r.Intn(10)
	this.ItemIDs = make([]string, v3)
	for i := 0; i < v3; i++ {
		this.ItemIDs[i] = string(randStringVault(r))
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedFetchReq(r randyVault, easy bool) *FetchReq {
	this := &FetchReq{}
	this.JWT = string(randStringVault(r))
	this.CollectionID = string(randStringVault(r))
	this.ItemID = string(randStringVault(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedFetchResp(r randyVault, easy bool) *FetchResp {
	this := &FetchResp{}
	v4 := r.Intn(100)
	this.Data = make([]byte, v4)
	for i := 0; i < v4; i++ {
		this.Data[i] = byte(r.Intn(256))
	}
	this.Mtime = uint64(uint64(r.Uint32()))
	this.End = bool(bool(r.Intn(2) == 0))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedStoreReq(r randyVault, easy bool) *StoreReq {
	this := &StoreReq{}
	oneofNumber_Msg := []int32{1, 2}[r.Intn(2)]
	switch oneofNumber_Msg {
	case 1:
		this.Msg = NewPopulatedStoreReq_Header_(r, easy)
	case 2:
		this.Msg = NewPopulatedStoreReq_Payload_(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedStoreReq_Header_(r randyVault, easy bool) *StoreReq_Header_ {
	this := &StoreReq_Header_{}
	this.Header = NewPopulatedStoreReq_Header(r, easy)
	return this
}
func NewPopulatedStoreReq_Payload_(r randyVault, easy bool) *StoreReq_Payload_ {
	this := &StoreReq_Payload_{}
	this.Payload = NewPopulatedStoreReq_Payload(r, easy)
	return this
}
func NewPopulatedStoreReq_Header(r randyVault, easy bool) *StoreReq_Header {
	this := &StoreReq_Header{}
	this.JWT = string(randStringVault(r))
	this.CollectionID = string(randStringVault(r))
	this.ItemID = string(randStringVault(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedStoreReq_Payload(r randyVault, easy bool) *StoreReq_Payload {
	this := &StoreReq_Payload{}
	v5 := r.Intn(100)
	this.Data = make([]byte, v5)
	for i := 0; i < v5; i++ {
		this.Data[i] = byte(r.Intn(256))
	}
	this.End = bool(bool(r.Intn(2) == 0))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedStoreResp(r randyVault, easy bool) *StoreResp {
	this := &StoreResp{}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedDeleteReq(r randyVault, easy bool) *DeleteReq {
	this := &DeleteReq{}
	this.JWT = string(randStringVault(r))
	this.CollectionID = string(randStringVault(r))
	this.ItemID = string(randStringVault(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedDeleteResp(r randyVault, easy bool) *DeleteResp {
	this := &DeleteResp{}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedSetUserCapabilitiesReq(r randyVault, easy bool) *SetUserCapabilitiesReq {
	this := &SetUserCapabilitiesReq{}
	this.JWT = string(randStringVault(r))
	v6 := redwood_dev_types.NewPopulatedAddress(r)
	this.Address = *v6
	v7 := r.Intn(10)
	this.Capabilities = make([]Capability, v7)
	for i := 0; i < v7; i++ {
		this.Capabilities[i] = Capability([]int32{0, 1, 2, 3, 4}[r.Intn(5)])
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedSetUserCapabilitiesResp(r randyVault, easy bool) *SetUserCapabilitiesResp {
	this := &SetUserCapabilitiesResp{}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

type randyVault interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneVault(r randyVault) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringVault(r randyVault) string {
	v8 := r.Intn(100)
	tmps := make([]rune, v8)
	for i := 0; i < v8; i++ {
		tmps[i] = randUTF8RuneVault(r)
	}
	return string(tmps)
}
func randUnrecognizedVault(r randyVault, maxFieldNumber int) (dAtA []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		dAtA = randFieldVault(dAtA, r, fieldNumber, wire)
	}
	return dAtA
}
func randFieldVault(dAtA []byte, r randyVault, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		dAtA = encodeVarintPopulateVault(dAtA, uint64(key))
		v9 := r.Int63()
		if r.Intn(2) == 0 {
			v9 *= -1
		}
		dAtA = encodeVarintPopulateVault(dAtA, uint64(v9))
	case 1:
		dAtA = encodeVarintPopulateVault(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		dAtA = encodeVarintPopulateVault(dAtA, uint64(key))
		ll := r.Intn(100)
		dAtA = encodeVarintPopulateVault(dAtA, uint64(ll))
		for j := 0; j < ll; j++ {
			dAtA = append(dAtA, byte(r.Intn(256)))
		}
	default:
		dAtA = encodeVarintPopulateVault(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return dAtA
}
func encodeVarintPopulateVault(dAtA []byte, v uint64) []byte {
	for v >= 1<<7 {
		dAtA = append(dAtA, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	dAtA = append(dAtA, uint8(v))
	return dAtA
}
func (m *AuthorizeMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Msg != nil {
		n += m.Msg.Size()
	}
	return n
}

func (m *AuthorizeMsg_Challenge_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Challenge != nil {
		l = m.Challenge.Size()
		n += 1 + l + sovVault(uint64(l))
	}
	return n
}
func (m *AuthorizeMsg_SignedChallenge_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SignedChallenge != nil {
		l = m.SignedChallenge.Size()
		n += 1 + l + sovVault(uint64(l))
	}
	return n
}
func (m *AuthorizeMsg_Response_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Response != nil {
		l = m.Response.Size()
		n += 1 + l + sovVault(uint64(l))
	}
	return n
}
func (m *AuthorizeMsg_Challenge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Challenge)
	if l > 0 {
		n += 1 + l + sovVault(uint64(l))
	}
	return n
}

func (m *AuthorizeMsg_SignedChallenge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Signature.Size()
	n += 1 + l + sovVault(uint64(l))
	return n
}

func (m *AuthorizeMsg_Response) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovVault(uint64(l))
	}
	return n
}

func (m *ItemsReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.JWT)
	if l > 0 {
		n += 1 + l + sovVault(uint64(l))
	}
	l = len(m.CollectionID)
	if l > 0 {
		n += 1 + l + sovVault(uint64(l))
	}
	if m.OldestMtime != 0 {
		n += 1 + sovVault(uint64(m.OldestMtime))
	}
	if m.Start != 0 {
		n += 1 + sovVault(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovVault(uint64(m.End))
	}
	return n
}

func (m *ItemsResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ItemIDs) > 0 {
		for _, s := range m.ItemIDs {
			l = len(s)
			n += 1 + l + sovVault(uint64(l))
		}
	}
	return n
}

func (m *FetchReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.JWT)
	if l > 0 {
		n += 1 + l + sovVault(uint64(l))
	}
	l = len(m.CollectionID)
	if l > 0 {
		n += 1 + l + sovVault(uint64(l))
	}
	l = len(m.ItemID)
	if l > 0 {
		n += 1 + l + sovVault(uint64(l))
	}
	return n
}

func (m *FetchResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovVault(uint64(l))
	}
	if m.Mtime != 0 {
		n += 1 + sovVault(uint64(m.Mtime))
	}
	if m.End {
		n += 2
	}
	return n
}

func (m *StoreReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Msg != nil {
		n += m.Msg.Size()
	}
	return n
}

func (m *StoreReq_Header_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovVault(uint64(l))
	}
	return n
}
func (m *StoreReq_Payload_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Payload != nil {
		l = m.Payload.Size()
		n += 1 + l + sovVault(uint64(l))
	}
	return n
}
func (m *StoreReq_Header) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.JWT)
	if l > 0 {
		n += 1 + l + sovVault(uint64(l))
	}
	l = len(m.CollectionID)
	if l > 0 {
		n += 1 + l + sovVault(uint64(l))
	}
	l = len(m.ItemID)
	if l > 0 {
		n += 1 + l + sovVault(uint64(l))
	}
	return n
}

func (m *StoreReq_Payload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovVault(uint64(l))
	}
	if m.End {
		n += 2
	}
	return n
}

func (m *StoreResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *DeleteReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.JWT)
	if l > 0 {
		n += 1 + l + sovVault(uint64(l))
	}
	l = len(m.CollectionID)
	if l > 0 {
		n += 1 + l + sovVault(uint64(l))
	}
	l = len(m.ItemID)
	if l > 0 {
		n += 1 + l + sovVault(uint64(l))
	}
	return n
}

func (m *DeleteResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *SetUserCapabilitiesReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.JWT)
	if l > 0 {
		n += 1 + l + sovVault(uint64(l))
	}
	l = m.Address.Size()
	n += 1 + l + sovVault(uint64(l))
	if len(m.Capabilities) > 0 {
		l = 0
		for _, e := range m.Capabilities {
			l += sovVault(uint64(e))
		}
		n += 1 + sovVault(uint64(l)) + l
	}
	return n
}

func (m *SetUserCapabilitiesResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovVault(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozVault(x uint64) (n int) {
	return sovVault(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *AuthorizeMsg) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AuthorizeMsg{`,
		`Msg:` + fmt.Sprintf("%v", this.Msg) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AuthorizeMsg_Challenge_) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AuthorizeMsg_Challenge_{`,
		`Challenge:` + strings.Replace(fmt.Sprintf("%v", this.Challenge), "AuthorizeMsg_Challenge", "AuthorizeMsg_Challenge", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AuthorizeMsg_SignedChallenge_) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AuthorizeMsg_SignedChallenge_{`,
		`SignedChallenge:` + strings.Replace(fmt.Sprintf("%v", this.SignedChallenge), "AuthorizeMsg_SignedChallenge", "AuthorizeMsg_SignedChallenge", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AuthorizeMsg_Response_) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AuthorizeMsg_Response_{`,
		`Response:` + strings.Replace(fmt.Sprintf("%v", this.Response), "AuthorizeMsg_Response", "AuthorizeMsg_Response", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AuthorizeMsg_Challenge) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AuthorizeMsg_Challenge{`,
		`Challenge:` + fmt.Sprintf("%v", this.Challenge) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AuthorizeMsg_SignedChallenge) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AuthorizeMsg_SignedChallenge{`,
		`Signature:` + fmt.Sprintf("%v", this.Signature) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AuthorizeMsg_Response) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AuthorizeMsg_Response{`,
		`Token:` + fmt.Sprintf("%v", this.Token) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ItemsReq) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ItemsReq{`,
		`JWT:` + fmt.Sprintf("%v", this.JWT) + `,`,
		`CollectionID:` + fmt.Sprintf("%v", this.CollectionID) + `,`,
		`OldestMtime:` + fmt.Sprintf("%v", this.OldestMtime) + `,`,
		`Start:` + fmt.Sprintf("%v", this.Start) + `,`,
		`End:` + fmt.Sprintf("%v", this.End) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ItemsResp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ItemsResp{`,
		`ItemIDs:` + fmt.Sprintf("%v", this.ItemIDs) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FetchReq) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FetchReq{`,
		`JWT:` + fmt.Sprintf("%v", this.JWT) + `,`,
		`CollectionID:` + fmt.Sprintf("%v", this.CollectionID) + `,`,
		`ItemID:` + fmt.Sprintf("%v", this.ItemID) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FetchResp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FetchResp{`,
		`Data:` + fmt.Sprintf("%v", this.Data) + `,`,
		`Mtime:` + fmt.Sprintf("%v", this.Mtime) + `,`,
		`End:` + fmt.Sprintf("%v", this.End) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StoreReq) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StoreReq{`,
		`Msg:` + fmt.Sprintf("%v", this.Msg) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StoreReq_Header_) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StoreReq_Header_{`,
		`Header:` + strings.Replace(fmt.Sprintf("%v", this.Header), "StoreReq_Header", "StoreReq_Header", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StoreReq_Payload_) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StoreReq_Payload_{`,
		`Payload:` + strings.Replace(fmt.Sprintf("%v", this.Payload), "StoreReq_Payload", "StoreReq_Payload", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StoreReq_Header) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StoreReq_Header{`,
		`JWT:` + fmt.Sprintf("%v", this.JWT) + `,`,
		`CollectionID:` + fmt.Sprintf("%v", this.CollectionID) + `,`,
		`ItemID:` + fmt.Sprintf("%v", this.ItemID) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StoreReq_Payload) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StoreReq_Payload{`,
		`Data:` + fmt.Sprintf("%v", this.Data) + `,`,
		`End:` + fmt.Sprintf("%v", this.End) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StoreResp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StoreResp{`,
		`}`,
	}, "")
	return s
}
func (this *DeleteReq) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DeleteReq{`,
		`JWT:` + fmt.Sprintf("%v", this.JWT) + `,`,
		`CollectionID:` + fmt.Sprintf("%v", this.CollectionID) + `,`,
		`ItemID:` + fmt.Sprintf("%v", this.ItemID) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeleteResp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DeleteResp{`,
		`}`,
	}, "")
	return s
}
func (this *SetUserCapabilitiesReq) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SetUserCapabilitiesReq{`,
		`JWT:` + fmt.Sprintf("%v", this.JWT) + `,`,
		`Address:` + fmt.Sprintf("%v", this.Address) + `,`,
		`Capabilities:` + fmt.Sprintf("%v", this.Capabilities) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SetUserCapabilitiesResp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SetUserCapabilitiesResp{`,
		`}`,
	}, "")
	return s
}
func valueToStringVault(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *AuthorizeMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVault
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthorizeMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthorizeMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Challenge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVault
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVault
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AuthorizeMsg_Challenge{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Msg = &AuthorizeMsg_Challenge_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignedChallenge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVault
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVault
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AuthorizeMsg_SignedChallenge{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Msg = &AuthorizeMsg_SignedChallenge_{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVault
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVault
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AuthorizeMsg_Response{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Msg = &AuthorizeMsg_Response_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVault(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVault
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthorizeMsg_Challenge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVault
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Challenge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Challenge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Challenge", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVault
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVault
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Challenge = append(m.Challenge[:0], dAtA[iNdEx:postIndex]...)
			if m.Challenge == nil {
				m.Challenge = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVault(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVault
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthorizeMsg_SignedChallenge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVault
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignedChallenge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignedChallenge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVault
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVault
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Signature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVault(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVault
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthorizeMsg_Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVault
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVault
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVault
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVault(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVault
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ItemsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVault
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ItemsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ItemsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JWT", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVault
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVault
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JWT = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVault
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVault
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldestMtime", wireType)
			}
			m.OldestMtime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OldestMtime |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVault(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVault
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ItemsResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVault
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ItemsResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ItemsResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemIDs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVault
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVault
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ItemIDs = append(m.ItemIDs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVault(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVault
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FetchReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVault
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FetchReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FetchReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JWT", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVault
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVault
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JWT = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVault
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVault
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVault
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVault
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ItemID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVault(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVault
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FetchResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVault
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FetchResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FetchResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVault
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVault
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtime", wireType)
			}
			m.Mtime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mtime |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.End = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipVault(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVault
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StoreReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVault
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StoreReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StoreReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVault
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVault
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StoreReq_Header{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Msg = &StoreReq_Header_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVault
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVault
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StoreReq_Payload{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Msg = &StoreReq_Payload_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVault(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVault
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StoreReq_Header) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVault
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Header: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Header: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JWT", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVault
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVault
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JWT = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVault
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVault
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVault
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVault
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ItemID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVault(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVault
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StoreReq_Payload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVault
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Payload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Payload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVault
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVault
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.End = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipVault(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVault
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StoreResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVault
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StoreResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StoreResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipVault(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVault
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVault
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JWT", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVault
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVault
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JWT = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVault
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVault
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVault
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVault
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ItemID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVault(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVault
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVault
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipVault(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVault
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetUserCapabilitiesReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVault
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetUserCapabilitiesReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetUserCapabilitiesReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JWT", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVault
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVault
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JWT = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVault
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVault
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Address.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v Capability
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVault
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= Capability(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Capabilities = append(m.Capabilities, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVault
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthVault
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthVault
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Capabilities) == 0 {
					m.Capabilities = make([]Capability, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v Capability
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVault
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= Capability(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Capabilities = append(m.Capabilities, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Capabilities", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVault(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVault
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetUserCapabilitiesResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVault
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetUserCapabilitiesResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetUserCapabilitiesResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipVault(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVault
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipVault(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowVault
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowVault
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowVault
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthVault
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupVault
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthVault
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthVault        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowVault          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupVault = fmt.Errorf("proto: unexpected end of group")
)
