// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: hush.proto

package pb

import (
	bytes "bytes"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
	redwood_dev_types "redwood.dev/types"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type DHPair struct {
	Private []byte `protobuf:"bytes,1,opt,name=private,proto3" json:"private,omitempty" tree:"privateKey"`
	Public  []byte `protobuf:"bytes,2,opt,name=public,proto3" json:"public,omitempty" tree:"publicKey"`
	Epoch   uint64 `protobuf:"varint,3,opt,name=epoch,proto3" json:"epoch,omitempty" tree:"epoch"`
}

func (m *DHPair) Reset()      { *m = DHPair{} }
func (*DHPair) ProtoMessage() {}
func (*DHPair) Descriptor() ([]byte, []int) {
	return fileDescriptor_ea3ebb9f2bccf9bd, []int{0}
}
func (m *DHPair) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DHPair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DHPair.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DHPair) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DHPair.Merge(m, src)
}
func (m *DHPair) XXX_Size() int {
	return m.Size()
}
func (m *DHPair) XXX_DiscardUnknown() {
	xxx_messageInfo_DHPair.DiscardUnknown(m)
}

var xxx_messageInfo_DHPair proto.InternalMessageInfo

func (m *DHPair) GetPrivate() []byte {
	if m != nil {
		return m.Private
	}
	return nil
}

func (m *DHPair) GetPublic() []byte {
	if m != nil {
		return m.Public
	}
	return nil
}

func (m *DHPair) GetEpoch() uint64 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

type DHPubkeyAttestation struct {
	Pubkey []byte `protobuf:"bytes,1,opt,name=pubkey,proto3" json:"pubkey,omitempty" tree:"pubkey"`
	Epoch  uint64 `protobuf:"varint,2,opt,name=epoch,proto3" json:"epoch,omitempty" tree:"epoch"`
	Sig    []byte `protobuf:"bytes,3,opt,name=sig,proto3" json:"sig,omitempty" tree:"sig"`
}

func (m *DHPubkeyAttestation) Reset()      { *m = DHPubkeyAttestation{} }
func (*DHPubkeyAttestation) ProtoMessage() {}
func (*DHPubkeyAttestation) Descriptor() ([]byte, []int) {
	return fileDescriptor_ea3ebb9f2bccf9bd, []int{1}
}
func (m *DHPubkeyAttestation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DHPubkeyAttestation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DHPubkeyAttestation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DHPubkeyAttestation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DHPubkeyAttestation.Merge(m, src)
}
func (m *DHPubkeyAttestation) XXX_Size() int {
	return m.Size()
}
func (m *DHPubkeyAttestation) XXX_DiscardUnknown() {
	xxx_messageInfo_DHPubkeyAttestation.DiscardUnknown(m)
}

var xxx_messageInfo_DHPubkeyAttestation proto.InternalMessageInfo

func (m *DHPubkeyAttestation) GetPubkey() []byte {
	if m != nil {
		return m.Pubkey
	}
	return nil
}

func (m *DHPubkeyAttestation) GetEpoch() uint64 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

func (m *DHPubkeyAttestation) GetSig() []byte {
	if m != nil {
		return m.Sig
	}
	return nil
}

type IndividualSessionID struct {
	SessionType string                    `protobuf:"bytes,1,opt,name=sessionType,proto3" json:"sessionType,omitempty" tree:"sessionType"`
	AliceAddr   redwood_dev_types.Address `protobuf:"bytes,2,opt,name=aliceAddr,proto3,customtype=redwood.dev/types.Address" json:"aliceAddr" tree:"aliceAddr"`
	BobAddr     redwood_dev_types.Address `protobuf:"bytes,3,opt,name=bobAddr,proto3,customtype=redwood.dev/types.Address" json:"bobAddr" tree:"bobAddr"`
	Epoch       uint64                    `protobuf:"varint,4,opt,name=epoch,proto3" json:"epoch,omitempty" tree:"epoch"`
}

func (m *IndividualSessionID) Reset()      { *m = IndividualSessionID{} }
func (*IndividualSessionID) ProtoMessage() {}
func (*IndividualSessionID) Descriptor() ([]byte, []int) {
	return fileDescriptor_ea3ebb9f2bccf9bd, []int{2}
}
func (m *IndividualSessionID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndividualSessionID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IndividualSessionID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IndividualSessionID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndividualSessionID.Merge(m, src)
}
func (m *IndividualSessionID) XXX_Size() int {
	return m.Size()
}
func (m *IndividualSessionID) XXX_DiscardUnknown() {
	xxx_messageInfo_IndividualSessionID.DiscardUnknown(m)
}

var xxx_messageInfo_IndividualSessionID proto.InternalMessageInfo

func (m *IndividualSessionID) GetSessionType() string {
	if m != nil {
		return m.SessionType
	}
	return ""
}

func (m *IndividualSessionID) GetEpoch() uint64 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

type IndividualSessionProposal struct {
	SessionID               IndividualSessionID    `protobuf:"bytes,1,opt,name=sessionID,proto3" json:"sessionID" tree:"sessionID"`
	SharedKey               SharedKey              `protobuf:"bytes,2,opt,name=sharedKey,proto3,customtype=SharedKey" json:"sharedKey" tree:"sharedKey"`
	AliceSig                []byte                 `protobuf:"bytes,3,opt,name=aliceSig,proto3" json:"aliceSig,omitempty" tree:"aliceSig"`
	ReplacesSessionWithHash redwood_dev_types.Hash `protobuf:"bytes,4,opt,name=replacesSessionWithHash,proto3,customtype=redwood.dev/types.Hash" json:"replacesSessionWithHash" tree:"replacesSessionWithHash"`
	RemoteDHPubkey          []byte                 `protobuf:"bytes,5,opt,name=remoteDHPubkey,proto3" json:"remoteDHPubkey,omitempty" tree:"remoteDHPubkey"`
}

func (m *IndividualSessionProposal) Reset()      { *m = IndividualSessionProposal{} }
func (*IndividualSessionProposal) ProtoMessage() {}
func (*IndividualSessionProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_ea3ebb9f2bccf9bd, []int{3}
}
func (m *IndividualSessionProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndividualSessionProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IndividualSessionProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IndividualSessionProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndividualSessionProposal.Merge(m, src)
}
func (m *IndividualSessionProposal) XXX_Size() int {
	return m.Size()
}
func (m *IndividualSessionProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_IndividualSessionProposal.DiscardUnknown(m)
}

var xxx_messageInfo_IndividualSessionProposal proto.InternalMessageInfo

func (m *IndividualSessionProposal) GetSessionID() IndividualSessionID {
	if m != nil {
		return m.SessionID
	}
	return IndividualSessionID{}
}

func (m *IndividualSessionProposal) GetAliceSig() []byte {
	if m != nil {
		return m.AliceSig
	}
	return nil
}

func (m *IndividualSessionProposal) GetRemoteDHPubkey() []byte {
	if m != nil {
		return m.RemoteDHPubkey
	}
	return nil
}

type IndividualSessionApproval struct {
	ProposalHash redwood_dev_types.Hash `protobuf:"bytes,1,opt,name=proposalHash,proto3,customtype=redwood.dev/types.Hash" json:"proposalHash" tree:"proposalHash"`
	BobSig       []byte                 `protobuf:"bytes,2,opt,name=bobSig,proto3" json:"bobSig,omitempty" tree:"bobSig"`
}

func (m *IndividualSessionApproval) Reset()      { *m = IndividualSessionApproval{} }
func (*IndividualSessionApproval) ProtoMessage() {}
func (*IndividualSessionApproval) Descriptor() ([]byte, []int) {
	return fileDescriptor_ea3ebb9f2bccf9bd, []int{4}
}
func (m *IndividualSessionApproval) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndividualSessionApproval) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IndividualSessionApproval.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IndividualSessionApproval) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndividualSessionApproval.Merge(m, src)
}
func (m *IndividualSessionApproval) XXX_Size() int {
	return m.Size()
}
func (m *IndividualSessionApproval) XXX_DiscardUnknown() {
	xxx_messageInfo_IndividualSessionApproval.DiscardUnknown(m)
}

var xxx_messageInfo_IndividualSessionApproval proto.InternalMessageInfo

func (m *IndividualSessionApproval) GetBobSig() []byte {
	if m != nil {
		return m.BobSig
	}
	return nil
}

type IndividualMessage struct {
	SessionHash redwood_dev_types.Hash   `protobuf:"bytes,1,opt,name=sessionHash,proto3,customtype=redwood.dev/types.Hash" json:"sessionHash" tree:"sessionHash"`
	Header      IndividualMessage_Header `protobuf:"bytes,2,opt,name=header,proto3" json:"header" tree:"header"`
	Ciphertext  []byte                   `protobuf:"bytes,3,opt,name=ciphertext,proto3" json:"ciphertext,omitempty" tree:"ciphertext"`
}

func (m *IndividualMessage) Reset()      { *m = IndividualMessage{} }
func (*IndividualMessage) ProtoMessage() {}
func (*IndividualMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_ea3ebb9f2bccf9bd, []int{5}
}
func (m *IndividualMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndividualMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IndividualMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IndividualMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndividualMessage.Merge(m, src)
}
func (m *IndividualMessage) XXX_Size() int {
	return m.Size()
}
func (m *IndividualMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_IndividualMessage.DiscardUnknown(m)
}

var xxx_messageInfo_IndividualMessage proto.InternalMessageInfo

func (m *IndividualMessage) GetHeader() IndividualMessage_Header {
	if m != nil {
		return m.Header
	}
	return IndividualMessage_Header{}
}

func (m *IndividualMessage) GetCiphertext() []byte {
	if m != nil {
		return m.Ciphertext
	}
	return nil
}

type IndividualMessage_Header struct {
	DhPubkey []byte `protobuf:"bytes,1,opt,name=dhPubkey,proto3" json:"dhPubkey,omitempty" tree:"dhPubkey"`
	N        uint32 `protobuf:"varint,2,opt,name=n,proto3" json:"n,omitempty" tree:"n"`
	Pn       uint32 `protobuf:"varint,3,opt,name=pn,proto3" json:"pn,omitempty" tree:"pn"`
}

func (m *IndividualMessage_Header) Reset()      { *m = IndividualMessage_Header{} }
func (*IndividualMessage_Header) ProtoMessage() {}
func (*IndividualMessage_Header) Descriptor() ([]byte, []int) {
	return fileDescriptor_ea3ebb9f2bccf9bd, []int{5, 0}
}
func (m *IndividualMessage_Header) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndividualMessage_Header) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IndividualMessage_Header.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IndividualMessage_Header) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndividualMessage_Header.Merge(m, src)
}
func (m *IndividualMessage_Header) XXX_Size() int {
	return m.Size()
}
func (m *IndividualMessage_Header) XXX_DiscardUnknown() {
	xxx_messageInfo_IndividualMessage_Header.DiscardUnknown(m)
}

var xxx_messageInfo_IndividualMessage_Header proto.InternalMessageInfo

func (m *IndividualMessage_Header) GetDhPubkey() []byte {
	if m != nil {
		return m.DhPubkey
	}
	return nil
}

func (m *IndividualMessage_Header) GetN() uint32 {
	if m != nil {
		return m.N
	}
	return 0
}

func (m *IndividualMessage_Header) GetPn() uint32 {
	if m != nil {
		return m.Pn
	}
	return 0
}

type GroupMessage struct {
	SessionType    string                       `protobuf:"bytes,1,opt,name=sessionType,proto3" json:"sessionType,omitempty" tree:"sessionType"`
	ID             string                       `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty" tree:"id"`
	EncryptionKeys []GroupMessage_EncryptionKey `protobuf:"bytes,3,rep,name=encryptionKeys,proto3" json:"encryptionKeys" tree:"encryptionKeys"`
	Ciphertext     []byte                       `protobuf:"bytes,4,opt,name=ciphertext,proto3" json:"ciphertext,omitempty" tree:"ciphertext"`
	Sig            []byte                       `protobuf:"bytes,5,opt,name=sig,proto3" json:"sig,omitempty" tree:"sig"`
}

func (m *GroupMessage) Reset()      { *m = GroupMessage{} }
func (*GroupMessage) ProtoMessage() {}
func (*GroupMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_ea3ebb9f2bccf9bd, []int{6}
}
func (m *GroupMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GroupMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GroupMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GroupMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GroupMessage.Merge(m, src)
}
func (m *GroupMessage) XXX_Size() int {
	return m.Size()
}
func (m *GroupMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_GroupMessage.DiscardUnknown(m)
}

var xxx_messageInfo_GroupMessage proto.InternalMessageInfo

func (m *GroupMessage) GetSessionType() string {
	if m != nil {
		return m.SessionType
	}
	return ""
}

func (m *GroupMessage) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *GroupMessage) GetEncryptionKeys() []GroupMessage_EncryptionKey {
	if m != nil {
		return m.EncryptionKeys
	}
	return nil
}

func (m *GroupMessage) GetCiphertext() []byte {
	if m != nil {
		return m.Ciphertext
	}
	return nil
}

func (m *GroupMessage) GetSig() []byte {
	if m != nil {
		return m.Sig
	}
	return nil
}

type GroupMessage_EncryptionKey struct {
	Recipient redwood_dev_types.Address `protobuf:"bytes,1,opt,name=recipient,proto3,customtype=redwood.dev/types.Address" json:"recipient" tree:"recipient"`
	Key       IndividualMessage         `protobuf:"bytes,2,opt,name=key,proto3" json:"key" tree:"key"`
}

func (m *GroupMessage_EncryptionKey) Reset()      { *m = GroupMessage_EncryptionKey{} }
func (*GroupMessage_EncryptionKey) ProtoMessage() {}
func (*GroupMessage_EncryptionKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_ea3ebb9f2bccf9bd, []int{6, 0}
}
func (m *GroupMessage_EncryptionKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GroupMessage_EncryptionKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GroupMessage_EncryptionKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GroupMessage_EncryptionKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GroupMessage_EncryptionKey.Merge(m, src)
}
func (m *GroupMessage_EncryptionKey) XXX_Size() int {
	return m.Size()
}
func (m *GroupMessage_EncryptionKey) XXX_DiscardUnknown() {
	xxx_messageInfo_GroupMessage_EncryptionKey.DiscardUnknown(m)
}

var xxx_messageInfo_GroupMessage_EncryptionKey proto.InternalMessageInfo

func (m *GroupMessage_EncryptionKey) GetKey() IndividualMessage {
	if m != nil {
		return m.Key
	}
	return IndividualMessage{}
}

func init() {
	proto.RegisterType((*DHPair)(nil), "Redwood.swarm.protohush.DHPair")
	proto.RegisterType((*DHPubkeyAttestation)(nil), "Redwood.swarm.protohush.DHPubkeyAttestation")
	proto.RegisterType((*IndividualSessionID)(nil), "Redwood.swarm.protohush.IndividualSessionID")
	proto.RegisterType((*IndividualSessionProposal)(nil), "Redwood.swarm.protohush.IndividualSessionProposal")
	proto.RegisterType((*IndividualSessionApproval)(nil), "Redwood.swarm.protohush.IndividualSessionApproval")
	proto.RegisterType((*IndividualMessage)(nil), "Redwood.swarm.protohush.IndividualMessage")
	proto.RegisterType((*IndividualMessage_Header)(nil), "Redwood.swarm.protohush.IndividualMessage.Header")
	proto.RegisterType((*GroupMessage)(nil), "Redwood.swarm.protohush.GroupMessage")
	proto.RegisterType((*GroupMessage_EncryptionKey)(nil), "Redwood.swarm.protohush.GroupMessage.EncryptionKey")
}

func init() { proto.RegisterFile("hush.proto", fileDescriptor_ea3ebb9f2bccf9bd) }

var fileDescriptor_ea3ebb9f2bccf9bd = []byte{
	// 978 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x55, 0x41, 0x8f, 0xdb, 0x44,
	0x14, 0xce, 0x38, 0xd9, 0xb4, 0x99, 0x24, 0x4b, 0x77, 0xc2, 0xb6, 0xd9, 0x95, 0x3a, 0x8e, 0x06,
	0x81, 0x16, 0x54, 0x12, 0xb1, 0x4b, 0x25, 0xb4, 0x27, 0xd6, 0x2c, 0x62, 0x57, 0xab, 0x4a, 0xd1,
	0x04, 0x81, 0xe0, 0x84, 0x1d, 0x0f, 0x89, 0x95, 0xac, 0x6d, 0x79, 0x9c, 0x2d, 0xe9, 0xa9, 0x67,
	0x2e, 0xf0, 0x13, 0xe8, 0x8d, 0x5f, 0x80, 0x38, 0x70, 0xe0, 0xd8, 0xe3, 0x1e, 0x2b, 0x84, 0xac,
	0xc6, 0x7b, 0xe1, 0x58, 0xf9, 0x54, 0xc1, 0x05, 0x79, 0x3c, 0x8e, 0x9d, 0xb4, 0x59, 0x22, 0x6e,
	0xf6, 0xbc, 0x6f, 0xbe, 0xf7, 0xcd, 0xf7, 0xde, 0x9b, 0x81, 0x70, 0x38, 0xe1, 0xc3, 0xb6, 0xeb,
	0x39, 0xbe, 0x83, 0xee, 0x50, 0x66, 0x3e, 0x74, 0x1c, 0xb3, 0xcd, 0x1f, 0xea, 0xde, 0x79, 0xb2,
	0x18, 0x87, 0x77, 0xdf, 0x1f, 0x58, 0xfe, 0x70, 0x62, 0xb4, 0xfb, 0xce, 0x79, 0x67, 0xe0, 0x0c,
	0x9c, 0x8e, 0x08, 0x19, 0x93, 0x6f, 0xc5, 0x9f, 0xf8, 0x11, 0x5f, 0xc9, 0x16, 0xf2, 0x03, 0x80,
	0xe5, 0xe3, 0x93, 0xae, 0x6e, 0x79, 0xa8, 0x03, 0x6f, 0xb8, 0x9e, 0x75, 0xa1, 0xfb, 0xac, 0x09,
	0x5a, 0x60, 0xaf, 0xa6, 0x6d, 0x47, 0x81, 0xba, 0xe5, 0x7b, 0x8c, 0x1d, 0x12, 0x19, 0x38, 0x63,
	0x53, 0x42, 0x53, 0x14, 0xba, 0x07, 0xcb, 0xee, 0xc4, 0x18, 0x5b, 0xfd, 0xa6, 0x22, 0xf0, 0x6f,
	0x46, 0x81, 0x7a, 0x4b, 0xe2, 0xc5, 0xba, 0x80, 0x4b, 0x0c, 0x7a, 0x07, 0x6e, 0x30, 0xd7, 0xe9,
	0x0f, 0x9b, 0xc5, 0x16, 0xd8, 0x2b, 0x69, 0xb7, 0xa2, 0x40, 0xad, 0x25, 0x60, 0xb1, 0x4c, 0x68,
	0x12, 0x26, 0xdf, 0x03, 0xd8, 0x38, 0x3e, 0xe9, 0x4e, 0x8c, 0x11, 0x9b, 0x1e, 0xf9, 0x3e, 0xe3,
	0xbe, 0xee, 0x5b, 0x8e, 0x8d, 0xde, 0x15, 0xd9, 0x46, 0x6c, 0x2a, 0xd5, 0x6d, 0x45, 0x81, 0x5a,
	0x9f, 0x67, 0x1b, 0xa5, 0xa9, 0x46, 0x6c, 0x9a, 0xa5, 0x52, 0xae, 0x4d, 0x85, 0x5a, 0xb0, 0xc8,
	0xad, 0x81, 0x10, 0x54, 0xd3, 0x36, 0xa3, 0x40, 0x85, 0x09, 0x8a, 0x5b, 0x03, 0x42, 0xe3, 0x10,
	0x79, 0xa2, 0xc0, 0xc6, 0xa9, 0x6d, 0x5a, 0x17, 0x96, 0x39, 0xd1, 0xc7, 0x3d, 0xc6, 0xb9, 0xe5,
	0xd8, 0xa7, 0xc7, 0xe8, 0x23, 0x58, 0xe5, 0xc9, 0xcf, 0xe7, 0x53, 0x37, 0xf1, 0xab, 0xa2, 0xdd,
	0x8e, 0x02, 0x15, 0x49, 0x86, 0x2c, 0x48, 0x68, 0x1e, 0x8a, 0x7a, 0xb0, 0xa2, 0x8f, 0xad, 0x3e,
	0x3b, 0x32, 0x4d, 0x4f, 0xfa, 0x76, 0xff, 0x69, 0xa0, 0x16, 0xfe, 0x08, 0xd4, 0x1d, 0x4f, 0xd6,
	0xd4, 0x64, 0x17, 0x1d, 0x7f, 0xea, 0x32, 0xde, 0x8e, 0x51, 0x8c, 0xf3, 0xcc, 0xd8, 0xf9, 0x5e,
	0x42, 0x33, 0x1e, 0xf4, 0x00, 0xde, 0x30, 0x1c, 0x43, 0x50, 0x26, 0x87, 0x39, 0x58, 0x87, 0x72,
	0x33, 0xa1, 0x94, 0x3b, 0x09, 0x4d, 0x39, 0x32, 0xff, 0x4a, 0xd7, 0xfa, 0x77, 0x58, 0x7a, 0xfc,
	0x67, 0xab, 0x40, 0x7e, 0x2b, 0xc2, 0x9d, 0x57, 0x3c, 0xea, 0x7a, 0x8e, 0xeb, 0x70, 0x7d, 0x8c,
	0x4c, 0x58, 0xe1, 0xa9, 0x6d, 0xc2, 0xa7, 0xea, 0xfe, 0xbd, 0xf6, 0x8a, 0xe6, 0x6d, 0xbf, 0xc6,
	0x6a, 0xad, 0x19, 0x1f, 0x25, 0x33, 0x60, 0x4e, 0x46, 0x68, 0x46, 0x8c, 0x3e, 0x81, 0x15, 0x3e,
	0xd4, 0x3d, 0x66, 0x9e, 0xb1, 0xa9, 0x74, 0xf5, 0x6d, 0x69, 0x41, 0xa5, 0x97, 0x06, 0x72, 0x24,
	0xe9, 0x52, 0x4c, 0x92, 0x7e, 0xa3, 0x0e, 0xbc, 0x29, 0x2c, 0xed, 0xcd, 0x7b, 0xa2, 0x11, 0x05,
	0xea, 0x1b, 0x39, 0xe3, 0x7b, 0x71, 0x63, 0xcc, 0x41, 0xe8, 0x11, 0xbc, 0xe3, 0x31, 0x77, 0xac,
	0xf7, 0x19, 0x97, 0x7a, 0xbf, 0xb4, 0xfc, 0xe1, 0x89, 0xce, 0x13, 0xe7, 0x6a, 0xda, 0xc7, 0x52,
	0xc3, 0xed, 0x57, 0xcb, 0x10, 0xa3, 0xa2, 0x40, 0xc5, 0x09, 0xfb, 0x0a, 0x1a, 0x42, 0x57, 0x25,
	0x40, 0x47, 0x70, 0xd3, 0x63, 0xe7, 0x8e, 0xcf, 0xd2, 0x59, 0x69, 0x6e, 0x88, 0x94, 0x3b, 0x51,
	0xa0, 0x6e, 0xa7, 0xa4, 0xf9, 0x38, 0xa1, 0x4b, 0x1b, 0x0e, 0x4b, 0x2f, 0x7f, 0x52, 0x0b, 0xe4,
	0x09, 0x78, 0x4d, 0xf9, 0x8e, 0x5c, 0xd7, 0x73, 0x2e, 0xf4, 0x31, 0xfa, 0x0a, 0xd6, 0x5c, 0x59,
	0x4a, 0x71, 0x2e, 0xb0, 0xd0, 0xb1, 0xab, 0xcf, 0xd5, 0x48, 0xef, 0x8d, 0x6c, 0x2f, 0xa1, 0x0b,
	0x54, 0xf1, 0x40, 0x1b, 0x8e, 0x11, 0x9b, 0xad, 0x2c, 0x0f, 0x74, 0xb2, 0x4e, 0xa8, 0x04, 0x90,
	0xbf, 0x15, 0xb8, 0x95, 0x69, 0x7c, 0xc0, 0x38, 0xd7, 0x07, 0x0c, 0x7d, 0x31, 0x1f, 0xc2, 0x9c,
	0xb4, 0x0f, 0xff, 0x53, 0xda, 0xe2, 0x88, 0x26, 0xca, 0xf2, 0x44, 0xe8, 0x1b, 0x58, 0x1e, 0x32,
	0xdd, 0x64, 0xc9, 0x7c, 0x56, 0xf7, 0x3f, 0x58, 0xa3, 0x5f, 0xa5, 0xa6, 0xf6, 0x89, 0xd8, 0xa8,
	0x6d, 0xcb, 0xa6, 0x95, 0xe7, 0x49, 0xe8, 0x08, 0x95, 0xbc, 0xe8, 0x3e, 0x84, 0x7d, 0xcb, 0x1d,
	0x32, 0xcf, 0x67, 0xdf, 0xf9, 0xb2, 0xd7, 0x72, 0xb7, 0x6d, 0x16, 0x23, 0x34, 0x07, 0xdc, 0xf5,
	0x61, 0x39, 0xe1, 0x8f, 0x5b, 0xd5, 0x1c, 0x76, 0xf3, 0xd7, 0x61, 0xae, 0x55, 0xd3, 0x08, 0xa1,
	0x73, 0x10, 0xda, 0x85, 0xc0, 0x16, 0xc7, 0xa9, 0x6b, 0xb5, 0x28, 0x50, 0x6f, 0x26, 0x48, 0x9b,
	0x50, 0x60, 0xa3, 0xbb, 0x50, 0x71, 0x6d, 0xa1, 0xa2, 0xae, 0xd5, 0xa3, 0x40, 0xad, 0xc8, 0xda,
	0xd9, 0x84, 0x2a, 0xae, 0x4d, 0xfe, 0x29, 0xc2, 0xda, 0x67, 0x9e, 0x33, 0x71, 0x53, 0xdf, 0xff,
	0xff, 0xe5, 0xf7, 0x16, 0x54, 0x2c, 0x53, 0xc8, 0xa8, 0x68, 0x8d, 0x30, 0x50, 0x95, 0xd3, 0xe3,
	0x2c, 0x9f, 0x65, 0x12, 0xaa, 0x58, 0x26, 0x7a, 0x04, 0x37, 0x99, 0xdd, 0xf7, 0xa6, 0x6e, 0x7c,
	0xed, 0x9f, 0xb1, 0x29, 0x6f, 0x16, 0x5b, 0xc5, 0xbd, 0xea, 0xfe, 0xc1, 0xca, 0x32, 0xe4, 0xd5,
	0xb5, 0x3f, 0xcd, 0xef, 0xd5, 0xee, 0xca, 0x42, 0xc8, 0x91, 0x58, 0x24, 0x26, 0x74, 0x29, 0xd3,
	0x52, 0x61, 0x4a, 0x6b, 0x16, 0x26, 0x7d, 0x48, 0x36, 0x56, 0x3e, 0x24, 0xbb, 0xbf, 0x00, 0x58,
	0x5f, 0x50, 0x16, 0x3f, 0x04, 0x1e, 0xeb, 0x5b, 0xae, 0xc5, 0x6c, 0x7f, 0x69, 0xac, 0xd6, 0x79,
	0x08, 0xe6, 0x7b, 0x09, 0xcd, 0x78, 0x50, 0x17, 0x16, 0x47, 0xf2, 0x06, 0xac, 0xee, 0xbf, 0xb7,
	0x7e, 0xdf, 0x6a, 0x48, 0xfa, 0x24, 0x85, 0x8b, 0xee, 0x89, 0xa9, 0x34, 0xf3, 0x72, 0x86, 0x0b,
	0xcf, 0x66, 0xb8, 0xf0, 0x7c, 0x86, 0xc1, 0x8b, 0x19, 0x06, 0x2f, 0x67, 0x18, 0x3c, 0x0e, 0x31,
	0xf8, 0x39, 0xc4, 0xe0, 0xd7, 0x10, 0x83, 0xdf, 0x43, 0x0c, 0x9e, 0x86, 0x18, 0x5c, 0x86, 0x18,
	0x3c, 0x0f, 0x31, 0xf8, 0x2b, 0xc4, 0x85, 0x17, 0x21, 0x06, 0x3f, 0x5e, 0xe1, 0xc2, 0xe5, 0x15,
	0x2e, 0x3c, 0xbb, 0xc2, 0x85, 0xaf, 0x71, 0xfe, 0x44, 0x42, 0x4d, 0x67, 0xae, 0xa6, 0xe3, 0x1a,
	0x46, 0x59, 0xfc, 0x1d, 0xfc, 0x1b, 0x00, 0x00, 0xff, 0xff, 0x72, 0xb5, 0xa3, 0xe5, 0xe3, 0x08,
	0x00, 0x00,
}

func (this *DHPair) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*DHPair)
	if !ok {
		that2, ok := that.(DHPair)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *DHPair")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *DHPair but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *DHPair but is not nil && this == nil")
	}
	if !bytes.Equal(this.Private, that1.Private) {
		return fmt.Errorf("Private this(%v) Not Equal that(%v)", this.Private, that1.Private)
	}
	if !bytes.Equal(this.Public, that1.Public) {
		return fmt.Errorf("Public this(%v) Not Equal that(%v)", this.Public, that1.Public)
	}
	if this.Epoch != that1.Epoch {
		return fmt.Errorf("Epoch this(%v) Not Equal that(%v)", this.Epoch, that1.Epoch)
	}
	return nil
}
func (this *DHPair) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DHPair)
	if !ok {
		that2, ok := that.(DHPair)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Private, that1.Private) {
		return false
	}
	if !bytes.Equal(this.Public, that1.Public) {
		return false
	}
	if this.Epoch != that1.Epoch {
		return false
	}
	return true
}
func (this *DHPubkeyAttestation) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*DHPubkeyAttestation)
	if !ok {
		that2, ok := that.(DHPubkeyAttestation)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *DHPubkeyAttestation")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *DHPubkeyAttestation but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *DHPubkeyAttestation but is not nil && this == nil")
	}
	if !bytes.Equal(this.Pubkey, that1.Pubkey) {
		return fmt.Errorf("Pubkey this(%v) Not Equal that(%v)", this.Pubkey, that1.Pubkey)
	}
	if this.Epoch != that1.Epoch {
		return fmt.Errorf("Epoch this(%v) Not Equal that(%v)", this.Epoch, that1.Epoch)
	}
	if !bytes.Equal(this.Sig, that1.Sig) {
		return fmt.Errorf("Sig this(%v) Not Equal that(%v)", this.Sig, that1.Sig)
	}
	return nil
}
func (this *DHPubkeyAttestation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DHPubkeyAttestation)
	if !ok {
		that2, ok := that.(DHPubkeyAttestation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Pubkey, that1.Pubkey) {
		return false
	}
	if this.Epoch != that1.Epoch {
		return false
	}
	if !bytes.Equal(this.Sig, that1.Sig) {
		return false
	}
	return true
}
func (this *IndividualSessionID) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*IndividualSessionID)
	if !ok {
		that2, ok := that.(IndividualSessionID)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *IndividualSessionID")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *IndividualSessionID but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *IndividualSessionID but is not nil && this == nil")
	}
	if this.SessionType != that1.SessionType {
		return fmt.Errorf("SessionType this(%v) Not Equal that(%v)", this.SessionType, that1.SessionType)
	}
	if !this.AliceAddr.Equal(that1.AliceAddr) {
		return fmt.Errorf("AliceAddr this(%v) Not Equal that(%v)", this.AliceAddr, that1.AliceAddr)
	}
	if !this.BobAddr.Equal(that1.BobAddr) {
		return fmt.Errorf("BobAddr this(%v) Not Equal that(%v)", this.BobAddr, that1.BobAddr)
	}
	if this.Epoch != that1.Epoch {
		return fmt.Errorf("Epoch this(%v) Not Equal that(%v)", this.Epoch, that1.Epoch)
	}
	return nil
}
func (this *IndividualSessionID) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IndividualSessionID)
	if !ok {
		that2, ok := that.(IndividualSessionID)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SessionType != that1.SessionType {
		return false
	}
	if !this.AliceAddr.Equal(that1.AliceAddr) {
		return false
	}
	if !this.BobAddr.Equal(that1.BobAddr) {
		return false
	}
	if this.Epoch != that1.Epoch {
		return false
	}
	return true
}
func (this *IndividualSessionProposal) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*IndividualSessionProposal)
	if !ok {
		that2, ok := that.(IndividualSessionProposal)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *IndividualSessionProposal")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *IndividualSessionProposal but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *IndividualSessionProposal but is not nil && this == nil")
	}
	if !this.SessionID.Equal(&that1.SessionID) {
		return fmt.Errorf("SessionID this(%v) Not Equal that(%v)", this.SessionID, that1.SessionID)
	}
	if !this.SharedKey.Equal(that1.SharedKey) {
		return fmt.Errorf("SharedKey this(%v) Not Equal that(%v)", this.SharedKey, that1.SharedKey)
	}
	if !bytes.Equal(this.AliceSig, that1.AliceSig) {
		return fmt.Errorf("AliceSig this(%v) Not Equal that(%v)", this.AliceSig, that1.AliceSig)
	}
	if !this.ReplacesSessionWithHash.Equal(that1.ReplacesSessionWithHash) {
		return fmt.Errorf("ReplacesSessionWithHash this(%v) Not Equal that(%v)", this.ReplacesSessionWithHash, that1.ReplacesSessionWithHash)
	}
	if !bytes.Equal(this.RemoteDHPubkey, that1.RemoteDHPubkey) {
		return fmt.Errorf("RemoteDHPubkey this(%v) Not Equal that(%v)", this.RemoteDHPubkey, that1.RemoteDHPubkey)
	}
	return nil
}
func (this *IndividualSessionProposal) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IndividualSessionProposal)
	if !ok {
		that2, ok := that.(IndividualSessionProposal)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SessionID.Equal(&that1.SessionID) {
		return false
	}
	if !this.SharedKey.Equal(that1.SharedKey) {
		return false
	}
	if !bytes.Equal(this.AliceSig, that1.AliceSig) {
		return false
	}
	if !this.ReplacesSessionWithHash.Equal(that1.ReplacesSessionWithHash) {
		return false
	}
	if !bytes.Equal(this.RemoteDHPubkey, that1.RemoteDHPubkey) {
		return false
	}
	return true
}
func (this *IndividualSessionApproval) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*IndividualSessionApproval)
	if !ok {
		that2, ok := that.(IndividualSessionApproval)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *IndividualSessionApproval")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *IndividualSessionApproval but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *IndividualSessionApproval but is not nil && this == nil")
	}
	if !this.ProposalHash.Equal(that1.ProposalHash) {
		return fmt.Errorf("ProposalHash this(%v) Not Equal that(%v)", this.ProposalHash, that1.ProposalHash)
	}
	if !bytes.Equal(this.BobSig, that1.BobSig) {
		return fmt.Errorf("BobSig this(%v) Not Equal that(%v)", this.BobSig, that1.BobSig)
	}
	return nil
}
func (this *IndividualSessionApproval) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IndividualSessionApproval)
	if !ok {
		that2, ok := that.(IndividualSessionApproval)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ProposalHash.Equal(that1.ProposalHash) {
		return false
	}
	if !bytes.Equal(this.BobSig, that1.BobSig) {
		return false
	}
	return true
}
func (this *IndividualMessage) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*IndividualMessage)
	if !ok {
		that2, ok := that.(IndividualMessage)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *IndividualMessage")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *IndividualMessage but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *IndividualMessage but is not nil && this == nil")
	}
	if !this.SessionHash.Equal(that1.SessionHash) {
		return fmt.Errorf("SessionHash this(%v) Not Equal that(%v)", this.SessionHash, that1.SessionHash)
	}
	if !this.Header.Equal(&that1.Header) {
		return fmt.Errorf("Header this(%v) Not Equal that(%v)", this.Header, that1.Header)
	}
	if !bytes.Equal(this.Ciphertext, that1.Ciphertext) {
		return fmt.Errorf("Ciphertext this(%v) Not Equal that(%v)", this.Ciphertext, that1.Ciphertext)
	}
	return nil
}
func (this *IndividualMessage) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IndividualMessage)
	if !ok {
		that2, ok := that.(IndividualMessage)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SessionHash.Equal(that1.SessionHash) {
		return false
	}
	if !this.Header.Equal(&that1.Header) {
		return false
	}
	if !bytes.Equal(this.Ciphertext, that1.Ciphertext) {
		return false
	}
	return true
}
func (this *IndividualMessage_Header) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*IndividualMessage_Header)
	if !ok {
		that2, ok := that.(IndividualMessage_Header)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *IndividualMessage_Header")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *IndividualMessage_Header but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *IndividualMessage_Header but is not nil && this == nil")
	}
	if !bytes.Equal(this.DhPubkey, that1.DhPubkey) {
		return fmt.Errorf("DhPubkey this(%v) Not Equal that(%v)", this.DhPubkey, that1.DhPubkey)
	}
	if this.N != that1.N {
		return fmt.Errorf("N this(%v) Not Equal that(%v)", this.N, that1.N)
	}
	if this.Pn != that1.Pn {
		return fmt.Errorf("Pn this(%v) Not Equal that(%v)", this.Pn, that1.Pn)
	}
	return nil
}
func (this *IndividualMessage_Header) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IndividualMessage_Header)
	if !ok {
		that2, ok := that.(IndividualMessage_Header)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.DhPubkey, that1.DhPubkey) {
		return false
	}
	if this.N != that1.N {
		return false
	}
	if this.Pn != that1.Pn {
		return false
	}
	return true
}
func (this *GroupMessage) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*GroupMessage)
	if !ok {
		that2, ok := that.(GroupMessage)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *GroupMessage")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *GroupMessage but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *GroupMessage but is not nil && this == nil")
	}
	if this.SessionType != that1.SessionType {
		return fmt.Errorf("SessionType this(%v) Not Equal that(%v)", this.SessionType, that1.SessionType)
	}
	if this.ID != that1.ID {
		return fmt.Errorf("ID this(%v) Not Equal that(%v)", this.ID, that1.ID)
	}
	if len(this.EncryptionKeys) != len(that1.EncryptionKeys) {
		return fmt.Errorf("EncryptionKeys this(%v) Not Equal that(%v)", len(this.EncryptionKeys), len(that1.EncryptionKeys))
	}
	for i := range this.EncryptionKeys {
		if !this.EncryptionKeys[i].Equal(&that1.EncryptionKeys[i]) {
			return fmt.Errorf("EncryptionKeys this[%v](%v) Not Equal that[%v](%v)", i, this.EncryptionKeys[i], i, that1.EncryptionKeys[i])
		}
	}
	if !bytes.Equal(this.Ciphertext, that1.Ciphertext) {
		return fmt.Errorf("Ciphertext this(%v) Not Equal that(%v)", this.Ciphertext, that1.Ciphertext)
	}
	if !bytes.Equal(this.Sig, that1.Sig) {
		return fmt.Errorf("Sig this(%v) Not Equal that(%v)", this.Sig, that1.Sig)
	}
	return nil
}
func (this *GroupMessage) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GroupMessage)
	if !ok {
		that2, ok := that.(GroupMessage)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SessionType != that1.SessionType {
		return false
	}
	if this.ID != that1.ID {
		return false
	}
	if len(this.EncryptionKeys) != len(that1.EncryptionKeys) {
		return false
	}
	for i := range this.EncryptionKeys {
		if !this.EncryptionKeys[i].Equal(&that1.EncryptionKeys[i]) {
			return false
		}
	}
	if !bytes.Equal(this.Ciphertext, that1.Ciphertext) {
		return false
	}
	if !bytes.Equal(this.Sig, that1.Sig) {
		return false
	}
	return true
}
func (this *GroupMessage_EncryptionKey) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*GroupMessage_EncryptionKey)
	if !ok {
		that2, ok := that.(GroupMessage_EncryptionKey)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *GroupMessage_EncryptionKey")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *GroupMessage_EncryptionKey but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *GroupMessage_EncryptionKey but is not nil && this == nil")
	}
	if !this.Recipient.Equal(that1.Recipient) {
		return fmt.Errorf("Recipient this(%v) Not Equal that(%v)", this.Recipient, that1.Recipient)
	}
	if !this.Key.Equal(&that1.Key) {
		return fmt.Errorf("Key this(%v) Not Equal that(%v)", this.Key, that1.Key)
	}
	return nil
}
func (this *GroupMessage_EncryptionKey) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GroupMessage_EncryptionKey)
	if !ok {
		that2, ok := that.(GroupMessage_EncryptionKey)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Recipient.Equal(that1.Recipient) {
		return false
	}
	if !this.Key.Equal(&that1.Key) {
		return false
	}
	return true
}
func (this *DHPair) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&pb.DHPair{")
	s = append(s, "Private: "+fmt.Sprintf("%#v", this.Private)+",\n")
	s = append(s, "Public: "+fmt.Sprintf("%#v", this.Public)+",\n")
	s = append(s, "Epoch: "+fmt.Sprintf("%#v", this.Epoch)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DHPubkeyAttestation) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&pb.DHPubkeyAttestation{")
	s = append(s, "Pubkey: "+fmt.Sprintf("%#v", this.Pubkey)+",\n")
	s = append(s, "Epoch: "+fmt.Sprintf("%#v", this.Epoch)+",\n")
	s = append(s, "Sig: "+fmt.Sprintf("%#v", this.Sig)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *IndividualSessionID) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&pb.IndividualSessionID{")
	s = append(s, "SessionType: "+fmt.Sprintf("%#v", this.SessionType)+",\n")
	s = append(s, "AliceAddr: "+fmt.Sprintf("%#v", this.AliceAddr)+",\n")
	s = append(s, "BobAddr: "+fmt.Sprintf("%#v", this.BobAddr)+",\n")
	s = append(s, "Epoch: "+fmt.Sprintf("%#v", this.Epoch)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *IndividualSessionProposal) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&pb.IndividualSessionProposal{")
	s = append(s, "SessionID: "+strings.Replace(this.SessionID.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "SharedKey: "+fmt.Sprintf("%#v", this.SharedKey)+",\n")
	s = append(s, "AliceSig: "+fmt.Sprintf("%#v", this.AliceSig)+",\n")
	s = append(s, "ReplacesSessionWithHash: "+fmt.Sprintf("%#v", this.ReplacesSessionWithHash)+",\n")
	s = append(s, "RemoteDHPubkey: "+fmt.Sprintf("%#v", this.RemoteDHPubkey)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *IndividualSessionApproval) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&pb.IndividualSessionApproval{")
	s = append(s, "ProposalHash: "+fmt.Sprintf("%#v", this.ProposalHash)+",\n")
	s = append(s, "BobSig: "+fmt.Sprintf("%#v", this.BobSig)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *IndividualMessage) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&pb.IndividualMessage{")
	s = append(s, "SessionHash: "+fmt.Sprintf("%#v", this.SessionHash)+",\n")
	s = append(s, "Header: "+strings.Replace(this.Header.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "Ciphertext: "+fmt.Sprintf("%#v", this.Ciphertext)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *IndividualMessage_Header) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&pb.IndividualMessage_Header{")
	s = append(s, "DhPubkey: "+fmt.Sprintf("%#v", this.DhPubkey)+",\n")
	s = append(s, "N: "+fmt.Sprintf("%#v", this.N)+",\n")
	s = append(s, "Pn: "+fmt.Sprintf("%#v", this.Pn)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GroupMessage) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&pb.GroupMessage{")
	s = append(s, "SessionType: "+fmt.Sprintf("%#v", this.SessionType)+",\n")
	s = append(s, "ID: "+fmt.Sprintf("%#v", this.ID)+",\n")
	if this.EncryptionKeys != nil {
		vs := make([]GroupMessage_EncryptionKey, len(this.EncryptionKeys))
		for i := range vs {
			vs[i] = this.EncryptionKeys[i]
		}
		s = append(s, "EncryptionKeys: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	s = append(s, "Ciphertext: "+fmt.Sprintf("%#v", this.Ciphertext)+",\n")
	s = append(s, "Sig: "+fmt.Sprintf("%#v", this.Sig)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GroupMessage_EncryptionKey) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&pb.GroupMessage_EncryptionKey{")
	s = append(s, "Recipient: "+fmt.Sprintf("%#v", this.Recipient)+",\n")
	s = append(s, "Key: "+strings.Replace(this.Key.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringHush(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *DHPair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DHPair) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DHPair) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Epoch != 0 {
		i = encodeVarintHush(dAtA, i, uint64(m.Epoch))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Public) > 0 {
		i -= len(m.Public)
		copy(dAtA[i:], m.Public)
		i = encodeVarintHush(dAtA, i, uint64(len(m.Public)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Private) > 0 {
		i -= len(m.Private)
		copy(dAtA[i:], m.Private)
		i = encodeVarintHush(dAtA, i, uint64(len(m.Private)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DHPubkeyAttestation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DHPubkeyAttestation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DHPubkeyAttestation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sig) > 0 {
		i -= len(m.Sig)
		copy(dAtA[i:], m.Sig)
		i = encodeVarintHush(dAtA, i, uint64(len(m.Sig)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Epoch != 0 {
		i = encodeVarintHush(dAtA, i, uint64(m.Epoch))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Pubkey) > 0 {
		i -= len(m.Pubkey)
		copy(dAtA[i:], m.Pubkey)
		i = encodeVarintHush(dAtA, i, uint64(len(m.Pubkey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IndividualSessionID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndividualSessionID) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndividualSessionID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Epoch != 0 {
		i = encodeVarintHush(dAtA, i, uint64(m.Epoch))
		i--
		dAtA[i] = 0x20
	}
	{
		size := m.BobAddr.Size()
		i -= size
		if _, err := m.BobAddr.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintHush(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.AliceAddr.Size()
		i -= size
		if _, err := m.AliceAddr.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintHush(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.SessionType) > 0 {
		i -= len(m.SessionType)
		copy(dAtA[i:], m.SessionType)
		i = encodeVarintHush(dAtA, i, uint64(len(m.SessionType)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IndividualSessionProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndividualSessionProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndividualSessionProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RemoteDHPubkey) > 0 {
		i -= len(m.RemoteDHPubkey)
		copy(dAtA[i:], m.RemoteDHPubkey)
		i = encodeVarintHush(dAtA, i, uint64(len(m.RemoteDHPubkey)))
		i--
		dAtA[i] = 0x2a
	}
	{
		size := m.ReplacesSessionWithHash.Size()
		i -= size
		if _, err := m.ReplacesSessionWithHash.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintHush(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.AliceSig) > 0 {
		i -= len(m.AliceSig)
		copy(dAtA[i:], m.AliceSig)
		i = encodeVarintHush(dAtA, i, uint64(len(m.AliceSig)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size := m.SharedKey.Size()
		i -= size
		if _, err := m.SharedKey.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintHush(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.SessionID.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintHush(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *IndividualSessionApproval) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndividualSessionApproval) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndividualSessionApproval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BobSig) > 0 {
		i -= len(m.BobSig)
		copy(dAtA[i:], m.BobSig)
		i = encodeVarintHush(dAtA, i, uint64(len(m.BobSig)))
		i--
		dAtA[i] = 0x12
	}
	{
		size := m.ProposalHash.Size()
		i -= size
		if _, err := m.ProposalHash.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintHush(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *IndividualMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndividualMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndividualMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ciphertext) > 0 {
		i -= len(m.Ciphertext)
		copy(dAtA[i:], m.Ciphertext)
		i = encodeVarintHush(dAtA, i, uint64(len(m.Ciphertext)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintHush(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.SessionHash.Size()
		i -= size
		if _, err := m.SessionHash.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintHush(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *IndividualMessage_Header) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndividualMessage_Header) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndividualMessage_Header) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pn != 0 {
		i = encodeVarintHush(dAtA, i, uint64(m.Pn))
		i--
		dAtA[i] = 0x18
	}
	if m.N != 0 {
		i = encodeVarintHush(dAtA, i, uint64(m.N))
		i--
		dAtA[i] = 0x10
	}
	if len(m.DhPubkey) > 0 {
		i -= len(m.DhPubkey)
		copy(dAtA[i:], m.DhPubkey)
		i = encodeVarintHush(dAtA, i, uint64(len(m.DhPubkey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GroupMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GroupMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GroupMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sig) > 0 {
		i -= len(m.Sig)
		copy(dAtA[i:], m.Sig)
		i = encodeVarintHush(dAtA, i, uint64(len(m.Sig)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Ciphertext) > 0 {
		i -= len(m.Ciphertext)
		copy(dAtA[i:], m.Ciphertext)
		i = encodeVarintHush(dAtA, i, uint64(len(m.Ciphertext)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.EncryptionKeys) > 0 {
		for iNdEx := len(m.EncryptionKeys) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.EncryptionKeys[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintHush(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintHush(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SessionType) > 0 {
		i -= len(m.SessionType)
		copy(dAtA[i:], m.SessionType)
		i = encodeVarintHush(dAtA, i, uint64(len(m.SessionType)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GroupMessage_EncryptionKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GroupMessage_EncryptionKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GroupMessage_EncryptionKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintHush(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.Recipient.Size()
		i -= size
		if _, err := m.Recipient.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintHush(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintHush(dAtA []byte, offset int, v uint64) int {
	offset -= sovHush(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func NewPopulatedDHPair(r randyHush, easy bool) *DHPair {
	this := &DHPair{}
	v1 := r.Intn(100)
	this.Private = make([]byte, v1)
	for i := 0; i < v1; i++ {
		this.Private[i] = byte(r.Intn(256))
	}
	v2 := r.Intn(100)
	this.Public = make([]byte, v2)
	for i := 0; i < v2; i++ {
		this.Public[i] = byte(r.Intn(256))
	}
	this.Epoch = uint64(uint64(r.Uint32()))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedDHPubkeyAttestation(r randyHush, easy bool) *DHPubkeyAttestation {
	this := &DHPubkeyAttestation{}
	v3 := r.Intn(100)
	this.Pubkey = make([]byte, v3)
	for i := 0; i < v3; i++ {
		this.Pubkey[i] = byte(r.Intn(256))
	}
	this.Epoch = uint64(uint64(r.Uint32()))
	v4 := r.Intn(100)
	this.Sig = make([]byte, v4)
	for i := 0; i < v4; i++ {
		this.Sig[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedIndividualSessionID(r randyHush, easy bool) *IndividualSessionID {
	this := &IndividualSessionID{}
	this.SessionType = string(randStringHush(r))
	v5 := redwood_dev_types.NewPopulatedAddress(r)
	this.AliceAddr = *v5
	v6 := redwood_dev_types.NewPopulatedAddress(r)
	this.BobAddr = *v6
	this.Epoch = uint64(uint64(r.Uint32()))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedIndividualSessionProposal(r randyHush, easy bool) *IndividualSessionProposal {
	this := &IndividualSessionProposal{}
	v7 := NewPopulatedIndividualSessionID(r, easy)
	this.SessionID = *v7
	v8 := NewPopulatedSharedKey(r)
	this.SharedKey = *v8
	v9 := r.Intn(100)
	this.AliceSig = make([]byte, v9)
	for i := 0; i < v9; i++ {
		this.AliceSig[i] = byte(r.Intn(256))
	}
	v10 := redwood_dev_types.NewPopulatedHash(r)
	this.ReplacesSessionWithHash = *v10
	v11 := r.Intn(100)
	this.RemoteDHPubkey = make([]byte, v11)
	for i := 0; i < v11; i++ {
		this.RemoteDHPubkey[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedIndividualSessionApproval(r randyHush, easy bool) *IndividualSessionApproval {
	this := &IndividualSessionApproval{}
	v12 := redwood_dev_types.NewPopulatedHash(r)
	this.ProposalHash = *v12
	v13 := r.Intn(100)
	this.BobSig = make([]byte, v13)
	for i := 0; i < v13; i++ {
		this.BobSig[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedIndividualMessage(r randyHush, easy bool) *IndividualMessage {
	this := &IndividualMessage{}
	v14 := redwood_dev_types.NewPopulatedHash(r)
	this.SessionHash = *v14
	v15 := NewPopulatedIndividualMessage_Header(r, easy)
	this.Header = *v15
	v16 := r.Intn(100)
	this.Ciphertext = make([]byte, v16)
	for i := 0; i < v16; i++ {
		this.Ciphertext[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedIndividualMessage_Header(r randyHush, easy bool) *IndividualMessage_Header {
	this := &IndividualMessage_Header{}
	v17 := r.Intn(100)
	this.DhPubkey = make([]byte, v17)
	for i := 0; i < v17; i++ {
		this.DhPubkey[i] = byte(r.Intn(256))
	}
	this.N = uint32(r.Uint32())
	this.Pn = uint32(r.Uint32())
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGroupMessage(r randyHush, easy bool) *GroupMessage {
	this := &GroupMessage{}
	this.SessionType = string(randStringHush(r))
	this.ID = string(randStringHush(r))
	if r.Intn(5) != 0 {
		v18 := r.Intn(5)
		this.EncryptionKeys = make([]GroupMessage_EncryptionKey, v18)
		for i := 0; i < v18; i++ {
			v19 := NewPopulatedGroupMessage_EncryptionKey(r, easy)
			this.EncryptionKeys[i] = *v19
		}
	}
	v20 := r.Intn(100)
	this.Ciphertext = make([]byte, v20)
	for i := 0; i < v20; i++ {
		this.Ciphertext[i] = byte(r.Intn(256))
	}
	v21 := r.Intn(100)
	this.Sig = make([]byte, v21)
	for i := 0; i < v21; i++ {
		this.Sig[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGroupMessage_EncryptionKey(r randyHush, easy bool) *GroupMessage_EncryptionKey {
	this := &GroupMessage_EncryptionKey{}
	v22 := redwood_dev_types.NewPopulatedAddress(r)
	this.Recipient = *v22
	v23 := NewPopulatedIndividualMessage(r, easy)
	this.Key = *v23
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

type randyHush interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneHush(r randyHush) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringHush(r randyHush) string {
	v24 := r.Intn(100)
	tmps := make([]rune, v24)
	for i := 0; i < v24; i++ {
		tmps[i] = randUTF8RuneHush(r)
	}
	return string(tmps)
}
func randUnrecognizedHush(r randyHush, maxFieldNumber int) (dAtA []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		dAtA = randFieldHush(dAtA, r, fieldNumber, wire)
	}
	return dAtA
}
func randFieldHush(dAtA []byte, r randyHush, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		dAtA = encodeVarintPopulateHush(dAtA, uint64(key))
		v25 := r.Int63()
		if r.Intn(2) == 0 {
			v25 *= -1
		}
		dAtA = encodeVarintPopulateHush(dAtA, uint64(v25))
	case 1:
		dAtA = encodeVarintPopulateHush(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		dAtA = encodeVarintPopulateHush(dAtA, uint64(key))
		ll := r.Intn(100)
		dAtA = encodeVarintPopulateHush(dAtA, uint64(ll))
		for j := 0; j < ll; j++ {
			dAtA = append(dAtA, byte(r.Intn(256)))
		}
	default:
		dAtA = encodeVarintPopulateHush(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return dAtA
}
func encodeVarintPopulateHush(dAtA []byte, v uint64) []byte {
	for v >= 1<<7 {
		dAtA = append(dAtA, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	dAtA = append(dAtA, uint8(v))
	return dAtA
}
func (m *DHPair) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Private)
	if l > 0 {
		n += 1 + l + sovHush(uint64(l))
	}
	l = len(m.Public)
	if l > 0 {
		n += 1 + l + sovHush(uint64(l))
	}
	if m.Epoch != 0 {
		n += 1 + sovHush(uint64(m.Epoch))
	}
	return n
}

func (m *DHPubkeyAttestation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Pubkey)
	if l > 0 {
		n += 1 + l + sovHush(uint64(l))
	}
	if m.Epoch != 0 {
		n += 1 + sovHush(uint64(m.Epoch))
	}
	l = len(m.Sig)
	if l > 0 {
		n += 1 + l + sovHush(uint64(l))
	}
	return n
}

func (m *IndividualSessionID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SessionType)
	if l > 0 {
		n += 1 + l + sovHush(uint64(l))
	}
	l = m.AliceAddr.Size()
	n += 1 + l + sovHush(uint64(l))
	l = m.BobAddr.Size()
	n += 1 + l + sovHush(uint64(l))
	if m.Epoch != 0 {
		n += 1 + sovHush(uint64(m.Epoch))
	}
	return n
}

func (m *IndividualSessionProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.SessionID.Size()
	n += 1 + l + sovHush(uint64(l))
	l = m.SharedKey.Size()
	n += 1 + l + sovHush(uint64(l))
	l = len(m.AliceSig)
	if l > 0 {
		n += 1 + l + sovHush(uint64(l))
	}
	l = m.ReplacesSessionWithHash.Size()
	n += 1 + l + sovHush(uint64(l))
	l = len(m.RemoteDHPubkey)
	if l > 0 {
		n += 1 + l + sovHush(uint64(l))
	}
	return n
}

func (m *IndividualSessionApproval) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ProposalHash.Size()
	n += 1 + l + sovHush(uint64(l))
	l = len(m.BobSig)
	if l > 0 {
		n += 1 + l + sovHush(uint64(l))
	}
	return n
}

func (m *IndividualMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.SessionHash.Size()
	n += 1 + l + sovHush(uint64(l))
	l = m.Header.Size()
	n += 1 + l + sovHush(uint64(l))
	l = len(m.Ciphertext)
	if l > 0 {
		n += 1 + l + sovHush(uint64(l))
	}
	return n
}

func (m *IndividualMessage_Header) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DhPubkey)
	if l > 0 {
		n += 1 + l + sovHush(uint64(l))
	}
	if m.N != 0 {
		n += 1 + sovHush(uint64(m.N))
	}
	if m.Pn != 0 {
		n += 1 + sovHush(uint64(m.Pn))
	}
	return n
}

func (m *GroupMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SessionType)
	if l > 0 {
		n += 1 + l + sovHush(uint64(l))
	}
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovHush(uint64(l))
	}
	if len(m.EncryptionKeys) > 0 {
		for _, e := range m.EncryptionKeys {
			l = e.Size()
			n += 1 + l + sovHush(uint64(l))
		}
	}
	l = len(m.Ciphertext)
	if l > 0 {
		n += 1 + l + sovHush(uint64(l))
	}
	l = len(m.Sig)
	if l > 0 {
		n += 1 + l + sovHush(uint64(l))
	}
	return n
}

func (m *GroupMessage_EncryptionKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Recipient.Size()
	n += 1 + l + sovHush(uint64(l))
	l = m.Key.Size()
	n += 1 + l + sovHush(uint64(l))
	return n
}

func sovHush(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozHush(x uint64) (n int) {
	return sovHush(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *DHPair) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DHPair{`,
		`Private:` + fmt.Sprintf("%v", this.Private) + `,`,
		`Public:` + fmt.Sprintf("%v", this.Public) + `,`,
		`Epoch:` + fmt.Sprintf("%v", this.Epoch) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DHPubkeyAttestation) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DHPubkeyAttestation{`,
		`Pubkey:` + fmt.Sprintf("%v", this.Pubkey) + `,`,
		`Epoch:` + fmt.Sprintf("%v", this.Epoch) + `,`,
		`Sig:` + fmt.Sprintf("%v", this.Sig) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IndividualSessionProposal) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IndividualSessionProposal{`,
		`SessionID:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.SessionID), "IndividualSessionID", "IndividualSessionID", 1), `&`, ``, 1) + `,`,
		`SharedKey:` + fmt.Sprintf("%v", this.SharedKey) + `,`,
		`AliceSig:` + fmt.Sprintf("%v", this.AliceSig) + `,`,
		`ReplacesSessionWithHash:` + fmt.Sprintf("%v", this.ReplacesSessionWithHash) + `,`,
		`RemoteDHPubkey:` + fmt.Sprintf("%v", this.RemoteDHPubkey) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IndividualSessionApproval) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IndividualSessionApproval{`,
		`ProposalHash:` + fmt.Sprintf("%v", this.ProposalHash) + `,`,
		`BobSig:` + fmt.Sprintf("%v", this.BobSig) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IndividualMessage) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IndividualMessage{`,
		`SessionHash:` + fmt.Sprintf("%v", this.SessionHash) + `,`,
		`Header:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Header), "IndividualMessage_Header", "IndividualMessage_Header", 1), `&`, ``, 1) + `,`,
		`Ciphertext:` + fmt.Sprintf("%v", this.Ciphertext) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IndividualMessage_Header) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IndividualMessage_Header{`,
		`DhPubkey:` + fmt.Sprintf("%v", this.DhPubkey) + `,`,
		`N:` + fmt.Sprintf("%v", this.N) + `,`,
		`Pn:` + fmt.Sprintf("%v", this.Pn) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GroupMessage) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForEncryptionKeys := "[]GroupMessage_EncryptionKey{"
	for _, f := range this.EncryptionKeys {
		repeatedStringForEncryptionKeys += fmt.Sprintf("%v", f) + ","
	}
	repeatedStringForEncryptionKeys += "}"
	s := strings.Join([]string{`&GroupMessage{`,
		`SessionType:` + fmt.Sprintf("%v", this.SessionType) + `,`,
		`ID:` + fmt.Sprintf("%v", this.ID) + `,`,
		`EncryptionKeys:` + repeatedStringForEncryptionKeys + `,`,
		`Ciphertext:` + fmt.Sprintf("%v", this.Ciphertext) + `,`,
		`Sig:` + fmt.Sprintf("%v", this.Sig) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GroupMessage_EncryptionKey) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GroupMessage_EncryptionKey{`,
		`Recipient:` + fmt.Sprintf("%v", this.Recipient) + `,`,
		`Key:` + strings.Replace(strings.Replace(this.Key.String(), "IndividualMessage", "IndividualMessage", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringHush(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *DHPair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHush
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DHPair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DHPair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Private", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHush
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthHush
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthHush
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Private = append(m.Private[:0], dAtA[iNdEx:postIndex]...)
			if m.Private == nil {
				m.Private = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Public", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHush
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthHush
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthHush
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Public = append(m.Public[:0], dAtA[iNdEx:postIndex]...)
			if m.Public == nil {
				m.Public = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHush
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHush(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthHush
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DHPubkeyAttestation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHush
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DHPubkeyAttestation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DHPubkeyAttestation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pubkey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHush
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthHush
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthHush
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pubkey = append(m.Pubkey[:0], dAtA[iNdEx:postIndex]...)
			if m.Pubkey == nil {
				m.Pubkey = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHush
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHush
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthHush
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthHush
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sig = append(m.Sig[:0], dAtA[iNdEx:postIndex]...)
			if m.Sig == nil {
				m.Sig = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHush(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthHush
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndividualSessionID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHush
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndividualSessionID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndividualSessionID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHush
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHush
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHush
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AliceAddr", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHush
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthHush
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthHush
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AliceAddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BobAddr", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHush
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthHush
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthHush
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BobAddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHush
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHush(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthHush
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndividualSessionProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHush
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndividualSessionProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndividualSessionProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHush
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHush
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHush
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SessionID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharedKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHush
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthHush
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthHush
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SharedKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AliceSig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHush
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthHush
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthHush
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AliceSig = append(m.AliceSig[:0], dAtA[iNdEx:postIndex]...)
			if m.AliceSig == nil {
				m.AliceSig = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplacesSessionWithHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHush
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthHush
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthHush
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ReplacesSessionWithHash.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteDHPubkey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHush
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthHush
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthHush
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemoteDHPubkey = append(m.RemoteDHPubkey[:0], dAtA[iNdEx:postIndex]...)
			if m.RemoteDHPubkey == nil {
				m.RemoteDHPubkey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHush(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthHush
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndividualSessionApproval) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHush
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndividualSessionApproval: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndividualSessionApproval: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHush
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthHush
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthHush
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ProposalHash.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BobSig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHush
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthHush
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthHush
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BobSig = append(m.BobSig[:0], dAtA[iNdEx:postIndex]...)
			if m.BobSig == nil {
				m.BobSig = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHush(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthHush
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndividualMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHush
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndividualMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndividualMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHush
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthHush
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthHush
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SessionHash.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHush
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHush
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHush
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ciphertext", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHush
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthHush
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthHush
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ciphertext = append(m.Ciphertext[:0], dAtA[iNdEx:postIndex]...)
			if m.Ciphertext == nil {
				m.Ciphertext = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHush(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthHush
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndividualMessage_Header) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHush
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Header: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Header: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DhPubkey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHush
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthHush
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthHush
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DhPubkey = append(m.DhPubkey[:0], dAtA[iNdEx:postIndex]...)
			if m.DhPubkey == nil {
				m.DhPubkey = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field N", wireType)
			}
			m.N = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHush
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.N |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pn", wireType)
			}
			m.Pn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHush
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pn |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHush(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthHush
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GroupMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHush
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GroupMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GroupMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHush
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHush
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHush
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHush
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHush
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHush
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptionKeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHush
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHush
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHush
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptionKeys = append(m.EncryptionKeys, GroupMessage_EncryptionKey{})
			if err := m.EncryptionKeys[len(m.EncryptionKeys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ciphertext", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHush
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthHush
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthHush
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ciphertext = append(m.Ciphertext[:0], dAtA[iNdEx:postIndex]...)
			if m.Ciphertext == nil {
				m.Ciphertext = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHush
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthHush
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthHush
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sig = append(m.Sig[:0], dAtA[iNdEx:postIndex]...)
			if m.Sig == nil {
				m.Sig = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHush(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthHush
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GroupMessage_EncryptionKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHush
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncryptionKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncryptionKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recipient", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHush
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthHush
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthHush
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Recipient.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHush
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHush
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHush
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHush(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthHush
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipHush(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowHush
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowHush
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowHush
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthHush
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupHush
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthHush
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthHush        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowHush          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupHush = fmt.Errorf("proto: unexpected end of group")
)
