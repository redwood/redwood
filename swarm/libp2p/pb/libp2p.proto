syntax = "proto3";

package Redwood.swarm.libp2p;
option go_package = "redwood.dev/swarm/libp2p/pb";

import "github.com/gogo/protobuf/gogoproto/gogo.proto";
import "blob/pb/blob.proto";
import "tree/pb/tx.proto";
import "swarm/protohush/pb/hush.proto";

option (gogoproto.gostring_all) = true;
option (gogoproto.equal_all) = false;
option (gogoproto.verbose_equal_all) = false;
option (gogoproto.goproto_stringer_all) = false;
option (gogoproto.stringer_all) =  true;
option (gogoproto.populate_all) = true;
option (gogoproto.testgen_all) = false;
option (gogoproto.benchgen_all) = true;
option (gogoproto.marshaler_all) = true;
option (gogoproto.sizer_all) = true;
option (gogoproto.unmarshaler_all) = true;

message AuthMessage {
    oneof payload {
        ChallengeRequest challengeRequest = 1;
        Challenge challenge = 2;
        Signatures signatures = 3;
        Ucan ucan = 4;
    }

    message ChallengeRequest {}

    message Challenge {
        bytes challenge = 1 [(gogoproto.customtype) = "redwood.dev/crypto.ChallengeMsg", (gogoproto.nullable) = false];
    }

    message Signatures {
        repeated bytes challenges = 1     [(gogoproto.customtype) = "redwood.dev/crypto.ChallengeMsg",  (gogoproto.nullable) = false];
        repeated bytes signatures = 2     [(gogoproto.customtype) = "redwood.dev/crypto.Signature",     (gogoproto.nullable) = false];
        repeated bytes asymEncPubkeys = 3 [(gogoproto.customtype) = "redwood.dev/crypto.AsymEncPubkey"];
    }

    message Ucan {
        string ucan = 1;
    }
}

message BlobMessage {
    oneof payload {
        FetchManifest fetchManifest = 1;
        SendManifest sendManifest = 2;
        FetchChunk fetchChunk = 3;
        SendChunk sendChunk = 4;
    }

    message FetchManifest {
        Redwood.blob.ID blobID = 1 [(gogoproto.nullable) = false, (gogoproto.customname) = "BlobID"];
    }

    message SendManifest {
        Redwood.blob.Manifest manifest = 1 [(gogoproto.nullable) = false];
        bool exists = 2;
    }

    message FetchChunk {
        bytes sha3 = 1 [(gogoproto.customname) = "SHA3"];
    }

    message SendChunk {
        bytes chunk = 1;
        bool exists = 2;
    }
}

message HushMessage {
    oneof payload {
        PubkeyBundles pubkeyBundles = 1;
    }

    message PubkeyBundles {
        repeated Redwood.swarm.protohush.PubkeyBundle bundles = 1 [(gogoproto.nullable) = false];
    }
}

message TreeMessage {
    oneof payload {
        Redwood.tree.Tx tx = 1;
        EncryptedTx encryptedTx = 2;
        Subscribe subscribe = 3;
        Ack ack = 4;
        AnnounceP2PStateURI announceP2PStateURI = 5;
    }

    message EncryptedTx {
        Redwood.swarm.protohush.GroupMessage encryptedTx = 1 [(gogoproto.nullable) = false];
    }

    message Subscribe {
        string stateURI = 1;
    }

    message SubscriptionMsg {
        oneof payload {
            Redwood.tree.Tx tx = 1;
            Redwood.swarm.protohush.GroupMessage encryptedTx = 2;
        }
    }

    message Ack {
        string stateURI = 1;
        bytes txID = 2 [(gogoproto.customtype) = "redwood.dev/state.Version", (gogoproto.nullable) = false];
    }

    message AnnounceP2PStateURI {
        string stateURI = 1;
    }
}

message PeerMessage {
    oneof payload {
        AnnouncePeers announcePeers = 1;
    }

    message AnnouncePeers {
        repeated bytes dialInfos = 1 [(gogoproto.customtype) = "redwood.dev/swarm.PeerDialInfo"];
    }
}
