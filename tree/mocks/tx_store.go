// Code generated by mockery v2.13.1. DO NOT EDIT.

package mocks

import (
	mock "github.com/stretchr/testify/mock"
	pb "redwood.dev/tree/pb"

	state "redwood.dev/state"

	tree "redwood.dev/tree"

	types "redwood.dev/types"
)

// TxStore is an autogenerated mock type for the TxStore type
type TxStore struct {
	mock.Mock
}

// AddTx provides a mock function with given fields: tx
func (_m *TxStore) AddTx(tx pb.Tx) error {
	ret := _m.Called(tx)

	var r0 error
	if rf, ok := ret.Get(0).(func(pb.Tx) error); ok {
		r0 = rf(tx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AllTxsForStateURI provides a mock function with given fields: stateURI, fromTxID
func (_m *TxStore) AllTxsForStateURI(stateURI string, fromTxID state.Version) (tree.TxIterator, error) {
	ret := _m.Called(stateURI, fromTxID)

	var r0 tree.TxIterator
	if rf, ok := ret.Get(0).(func(string, state.Version) tree.TxIterator); ok {
		r0 = rf(stateURI, fromTxID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(tree.TxIterator)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, state.Version) error); ok {
		r1 = rf(stateURI, fromTxID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AllValidTxsForStateURIOrdered provides a mock function with given fields: stateURI, fromTxID
func (_m *TxStore) AllValidTxsForStateURIOrdered(stateURI string, fromTxID state.Version) tree.TxIterator {
	ret := _m.Called(stateURI, fromTxID)

	var r0 tree.TxIterator
	if rf, ok := ret.Get(0).(func(string, state.Version) tree.TxIterator); ok {
		r0 = rf(stateURI, fromTxID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(tree.TxIterator)
		}
	}

	return r0
}

// Close provides a mock function with given fields:
func (_m *TxStore) Close() {
	_m.Called()
}

// DebugPrint provides a mock function with given fields:
func (_m *TxStore) DebugPrint() {
	_m.Called()
}

// FetchTx provides a mock function with given fields: stateURI, txID
func (_m *TxStore) FetchTx(stateURI string, txID state.Version) (pb.Tx, error) {
	ret := _m.Called(stateURI, txID)

	var r0 pb.Tx
	if rf, ok := ret.Get(0).(func(string, state.Version) pb.Tx); ok {
		r0 = rf(stateURI, txID)
	} else {
		r0 = ret.Get(0).(pb.Tx)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, state.Version) error); ok {
		r1 = rf(stateURI, txID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IsStateURIWithData provides a mock function with given fields: stateURI
func (_m *TxStore) IsStateURIWithData(stateURI string) (bool, error) {
	ret := _m.Called(stateURI)

	var r0 bool
	if rf, ok := ret.Get(0).(func(string) bool); ok {
		r0 = rf(stateURI)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(stateURI)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Leaves provides a mock function with given fields: stateURI
func (_m *TxStore) Leaves(stateURI string) ([]state.Version, error) {
	ret := _m.Called(stateURI)

	var r0 []state.Version
	if rf, ok := ret.Get(0).(func(string) []state.Version); ok {
		r0 = rf(stateURI)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]state.Version)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(stateURI)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MarkLeaf provides a mock function with given fields: stateURI, txID
func (_m *TxStore) MarkLeaf(stateURI string, txID state.Version) error {
	ret := _m.Called(stateURI, txID)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, state.Version) error); ok {
		r0 = rf(stateURI, txID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// OnNewStateURIWithData provides a mock function with given fields: fn
func (_m *TxStore) OnNewStateURIWithData(fn tree.NewStateURIWithDataCallback) {
	_m.Called(fn)
}

// RemoveTx provides a mock function with given fields: stateURI, txID
func (_m *TxStore) RemoveTx(stateURI string, txID state.Version) error {
	ret := _m.Called(stateURI, txID)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, state.Version) error); ok {
		r0 = rf(stateURI, txID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Start provides a mock function with given fields:
func (_m *TxStore) Start() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StateURIsWithData provides a mock function with given fields:
func (_m *TxStore) StateURIsWithData() (types.Set[string], error) {
	ret := _m.Called()

	var r0 types.Set[string]
	if rf, ok := ret.Get(0).(func() types.Set[string]); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(types.Set[string])
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TxExists provides a mock function with given fields: stateURI, txID
func (_m *TxStore) TxExists(stateURI string, txID state.Version) (bool, error) {
	ret := _m.Called(stateURI, txID)

	var r0 bool
	if rf, ok := ret.Get(0).(func(string, state.Version) bool); ok {
		r0 = rf(stateURI, txID)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, state.Version) error); ok {
		r1 = rf(stateURI, txID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UnmarkLeaf provides a mock function with given fields: stateURI, txID
func (_m *TxStore) UnmarkLeaf(stateURI string, txID state.Version) error {
	ret := _m.Called(stateURI, txID)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, state.Version) error); ok {
		r0 = rf(stateURI, txID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type mockConstructorTestingTNewTxStore interface {
	mock.TestingT
	Cleanup(func())
}

// NewTxStore creates a new instance of TxStore. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewTxStore(t mockConstructorTestingTNewTxStore) *TxStore {
	mock := &TxStore{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
